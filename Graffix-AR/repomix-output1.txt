This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-03T13:58:23.024Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
App/
  Graffix-ARApp.swift
  Info.plist
Assets/
  Assets.xcassets/
    AccentColor.colorset/
      Contents.json
    AppIcon.appiconset/
      Contents.json
    Contents.json
  Preview Content/
    Preview Assets.xcassets/
      Contents.json
Common/
  Cache/
    BaseCache.swift
    CacheError.swift
  Errors/
    AppError.swift
    ErrorHandling.swift
  Extensions/
    SIMD4+Extensions.swift
    UIView+Extensions.swift
  Protocols/
    ErrorHandlingViewModel.swift
  Services/
    Memory/
      MemoryManagementDelegate.swift
      MemoryManagementService.swift
      MemoryManagementServiceImpl.swift
  ViewModels/
    BaseViewModel.swift
Features/
  Common/
    Models/
      ARConfigurationOptions.swift
    Protocols/
      ARConfigurationService.swift
      Cacheable.swift
    Services/
      ARConfigurationServiceImpl.swift
      ARConfigurationSettings.swift
      ARServices.swift
      ARServicesProvider.swift
      DevicePerformanceMonitor.swift
    ViewModels/
      ARViewModel.swift
  DistanceMeasurement/
    Models/
      DistanceData.swift
      SensorType.swift
    Services/
      SensorManager.swift
    ViewModels/
      DistanceViewModel.swift
      MeasurementViewModel.swift
  WallDetection/
    Models/
      WallDetectionEvent.swift
      WallDetectionMode.swift
    Services/
      WallDetectionService.swift
      WallDistanceTracker.swift
    ViewModels/
      WallDetectionViewModel.swift
      WallTargetingViewModel.swift
    Views/
      ARView/
        Coordinators/
          ARSceneCoordinator.swift
        Rendering/
          PlaneNodeCache.swift
          PlaneNodeFactory.swift
          PlaneNodeUpdater.swift
        WallManagement/
          WallColorManager.swift
          WallGroupCache.swift
          WallGroupManager.swift
        ARMainContentView.swift
        ARViewContainer.swift
      Components/
        ReticuleMark.swift
        WallDetectionOverlay.swift
        WallIndicator.swift
      MainView.swift
Resources/
  Localization/
    ja.lproj/
      Localizable.strings

================================================================
Files
================================================================

================
File: App/Graffix-ARApp.swift
================
import SwiftUI

@main
struct GraffixARApp: App {
    var body: some Scene {
        WindowGroup {
            MainView()
        }
    }
}

================
File: App/Info.plist
================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>CFBundleIdentifier</key>
    <string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
    
    <key>NSCameraUsageDescription</key>
    <string>ARでの壁面検出と距離測定のためにカメラを使用します。</string>
    
    <key>CFBundleName</key>
    <string>$(PRODUCT_NAME)</string>
    
    <key>UISupportedInterfaceOrientations</key>
    <array>
        <string>UIInterfaceOrientationPortrait</string>
    </array>
    
    <key>MinimumOSVersion</key>
    <string>18.1</string>
    
    <key>LSRequiresIPhoneOS</key>
    <true/>
</dict>
</plist>

================
File: Assets/Assets.xcassets/AccentColor.colorset/Contents.json
================
{
  "colors" : [
    {
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

================
File: Assets/Assets.xcassets/AppIcon.appiconset/Contents.json
================
{
  "images" : [
    {
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    },
    {
      "appearances" : [
        {
          "appearance" : "luminosity",
          "value" : "dark"
        }
      ],
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    },
    {
      "appearances" : [
        {
          "appearance" : "luminosity",
          "value" : "tinted"
        }
      ],
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

================
File: Assets/Assets.xcassets/Contents.json
================
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

================
File: Assets/Preview Content/Preview Assets.xcassets/Contents.json
================
{
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}

================
File: Common/Cache/BaseCache.swift
================
import Foundation

actor BaseCache<T> {
    let maxItems: Int
    let cleanupInterval: TimeInterval
    private(set) var isInitialized = false
    
    private var items: [UUID: (item: T, metadata: CacheMetadata)] = [:]
    private var lastCleanupTime: Date
    private var cleanupTask: Task<Void, Never>?
    
    init(maxItems: Int, cleanupInterval: TimeInterval) {
        self.maxItems = maxItems
        self.cleanupInterval = cleanupInterval
        self.lastCleanupTime = Date()
    }
    
    func initialize() throws {
        guard !isInitialized else { return }
        isInitialized = true
        startAutoCleanup()
    }
    
    func store(_ item: T, forKey key: UUID) async throws {
        try validateInitialization()
        
        if items.count >= maxItems {
            try await performEmergencyCleanup()
        }
        
        items[key] = (
            item: item,
            metadata: CacheMetadata(
                lastAccessed: Date(),
                createdAt: Date()
            )
        )
    }
    
    func get(forKey key: UUID) async throws -> T {
        try validateInitialization()
        
        guard let cached = items[key] else {
            throw CacheError.itemNotFound(key)
        }
        
        // アクセス時間を更新
        items[key] = (
            item: cached.item,
            metadata: CacheMetadata(
                lastAccessed: Date(),
                createdAt: cached.metadata.createdAt
            )
        )
        
        return cached.item
    }
    
    func remove(forKey key: UUID) async throws {
        try validateInitialization()
        items.removeValue(forKey: key)
    }
    
    func performCleanup() async throws {
        try validateInitialization()
        
        let now = Date()
        let oldItems = items.filter {
            now.timeIntervalSince($0.value.metadata.lastAccessed) > cleanupInterval
        }
        
        for key in oldItems.keys {
            try await remove(forKey: key)
        }
        
        lastCleanupTime = now
    }
    
    var count: Int {
        get async {
            items.count
        }
    }
    
    var keys: [UUID] {
        get async {
            Array(items.keys)
        }
    }
    
    func getMetadata(for key: UUID) async throws -> CacheMetadata {
        try validateInitialization()
        guard let item = items[key] else {
            throw CacheError.itemNotFound(key)
        }
        return item.metadata
    }
    
    // MARK: - Private Methods
    
    private func validateInitialization() throws {
        guard isInitialized else {
            throw CacheError.notInitialized
        }
    }
    
    private func startAutoCleanup() {
        cleanupTask = Task { [weak self] in
            while !Task.isCancelled {
                do {
                    try await Task.sleep(nanoseconds: UInt64(self?.cleanupInterval ?? 15 * 1_000_000_000))
                    try await self?.performCleanup()
                } catch {
                    if !Task.isCancelled {
                        print("Cache cleanup error: \(error.localizedDescription)")
                    }
                }
            }
        }
    }
    
    func performEmergencyCleanup() async throws {
        let itemsToRemove = Int(Double(items.count) * 0.2)
        let sortedItems = items.sorted { $0.value.metadata.lastAccessed < $1.value.metadata.lastAccessed }
        
        for i in 0..<min(itemsToRemove, sortedItems.count) {
            try await remove(forKey: sortedItems[i].key)
        }
    }
    
    deinit {
        cleanupTask?.cancel()
    }
}

================
File: Common/Cache/CacheError.swift
================
import Foundation

enum CacheError: LocalizedError {
    case notInitialized
    case itemNotFound(UUID)
    case capacityExceeded
    case invalidState(String)
    
    var errorDescription: String? {
        switch self {
        case .notInitialized:
            return "キャッシュが初期化されていません"
        case .itemNotFound(let id):
            return "アイテムが見つかりません: \(id)"
        case .capacityExceeded:
            return "キャッシュの容量を超えました"
        case .invalidState(let message):
            return "不正な状態: \(message)"
        }
    }
}

================
File: Common/Errors/AppError.swift
================
import ARKit
import Foundation

enum AppError: LocalizedError {
    case ar(ARError)
    case sensor(SensorError)
    case system(SystemError)
    
    // MARK: - Nested Error Types
    
    enum ARError {
        case trackingStateChanged(ARCamera.TrackingState)
        case sessionFailed(Error)
        case notAvailable
        case initialization
        case relocalizing
        case insufficientFeatures
        case excessiveMotion
        case cacheError(String)
        case wallGroupError(String)
    }
    
    enum SensorError {
        case initializationFailed
        case calibrationRequired
        case systemOverload
        case consecutiveErrors
        case resourceUnavailable
        case measurementError(String)
        case dataInvalid
    }
    
    enum SystemError {
        case memoryWarning
        case taskCancelled
        case resourceLimit(String)
        case unexpectedState(String)
    }
}

// MARK: - Error Descriptions
extension AppError {
    var errorDescription: String? {
        switch self {
        case .ar(let error):
            return error.localizedDescription
        case .sensor(let error):
            return error.localizedDescription
        case .system(let error):
            return error.localizedDescription
        }
    }
    
    var recoverySuggestion: String? {
        switch self {
        case .ar(let error):
            return error.recoverySuggestion
        case .sensor(let error):
            return error.recoverySuggestion
        case .system(let error):
            return error.recoverySuggestion
        }
    }
}

// MARK: - AR Error Descriptions
extension AppError.ARError {
    var localizedDescription: String {
        switch self {
        case .trackingStateChanged(let state):
            switch state {
            case .normal:
                return String(localized: "ar.tracking.normal")
            case .limited(let reason):
                switch reason {
                case .excessiveMotion:
                    return String(localized: "ar.tracking.excessive_motion")
                case .insufficientFeatures:
                    return String(localized: "ar.tracking.insufficient_features")
                case .initializing:
                    return String(localized: "ar.tracking.initializing")
                case .relocalizing:
                    return String(localized: "ar.tracking.relocalizing")
                @unknown default:
                    return String(localized: "ar.tracking.limited")
                }
            case .notAvailable:
                return String(localized: "ar.tracking.not_available")
            }
        case .sessionFailed(let error):
            return String(localized: "ar.session.failed") + ": \(error.localizedDescription)"
        case .notAvailable:
            return String(localized: "ar.not_available")
        case .initialization:
            return String(localized: "ar.initialization")
        case .relocalizing:
            return String(localized: "ar.relocalizing")
        case .insufficientFeatures:
            return String(localized: "ar.insufficient_features")
        case .excessiveMotion:
            return String(localized: "ar.excessive_motion")
        case .cacheError(let message):
            return String(format: String(localized: "ar.cache.error"), message)
        case .wallGroupError(let message):
            return String(format: String(localized: "ar.wall.error"), message)
        }
    }
    
    var recoverySuggestion: String {
        switch self {
        case .trackingStateChanged(let state):
            switch state {
            case .limited(let reason):
                switch reason {
                case .excessiveMotion:
                    return String(localized: "ar.recovery.slow_down")
                case .insufficientFeatures:
                    return String(localized: "ar.recovery.more_features")
                case .initializing, .relocalizing:
                    return String(localized: "ar.recovery.wait")
                @unknown default:
                    return String(localized: "ar.recovery.general")
                }
            case .notAvailable:
                return String(localized: "ar.recovery.restart")
            case .normal:
                return ""
            }
        case .sessionFailed:
            return String(localized: "ar.recovery.restart_session")
        case .notAvailable:
            return String(localized: "ar.recovery.check_device")
        case .initialization:
            return String(localized: "ar.recovery.wait")
        case .relocalizing:
            return String(localized: "ar.recovery.scan_area")
        case .insufficientFeatures:
            return String(localized: "ar.recovery.more_light")
        case .excessiveMotion:
            return String(localized: "ar.recovery.slow_down")
        case .cacheError:
            return String(localized: "ar.recovery.restart_app")
        case .wallGroupError:
            return String(localized: "ar.recovery.rescan_wall")
        }
    }
}

// MARK: - Sensor Error Descriptions
extension AppError.SensorError {
    var localizedDescription: String {
        switch self {
        case .initializationFailed:
            return String(localized: "sensor.init.failed")
        case .calibrationRequired:
            return String(localized: "sensor.calibration.required")
        case .systemOverload:
            return String(localized: "sensor.system.overload")
        case .consecutiveErrors:
            return String(localized: "sensor.consecutive.errors")
        case .resourceUnavailable:
            return String(localized: "sensor.resource.unavailable")
        case .measurementError(let message):
            return String(format: String(localized: "sensor.measurement.error"), message)
        case .dataInvalid:
            return String(localized: "sensor.data.invalid")
        }
    }
    
    var recoverySuggestion: String {
        switch self {
        case .initializationFailed:
            return String(localized: "sensor.recovery.restart")
        case .calibrationRequired:
            return String(localized: "sensor.recovery.calibrate")
        case .systemOverload:
            return String(localized: "sensor.recovery.close_apps")
        case .consecutiveErrors:
            return String(localized: "sensor.recovery.reset")
        case .resourceUnavailable:
            return String(localized: "sensor.recovery.check_usage")
        case .measurementError:
            return String(localized: "sensor.recovery.retry")
        case .dataInvalid:
            return String(localized: "sensor.recovery.retry")
        }
    }
}

// MARK: - System Error Descriptions
extension AppError.SystemError {
    var localizedDescription: String {
        switch self {
        case .memoryWarning:
            return String(localized: "system.memory.warning")
        case .taskCancelled:
            return String(localized: "system.task.cancelled")
        case .resourceLimit(let message):
            return String(format: String(localized: "system.resource.limit"), message)
        case .unexpectedState(let message):
            return String(format: String(localized: "system.unexpected.state"), message)
        }
    }
    
    var recoverySuggestion: String {
        switch self {
        case .memoryWarning:
            return String(localized: "system.recovery.free_memory")
        case .taskCancelled:
            return String(localized: "system.recovery.retry")
        case .resourceLimit:
            return String(localized: "system.recovery.free_resources")
        case .unexpectedState:
            return String(localized: "system.recovery.restart")
        }
    }
}

================
File: Common/Errors/ErrorHandling.swift
================
import Foundation
import UIKit

protocol ErrorHandling: AnyObject {
    func handle(_ error: AppError)
    func recover(from error: AppError) async throws
    func showError(_ error: AppError)
    func logError(_ error: AppError)
}

final class AppErrorHandler: ErrorHandling {
    static let shared = AppErrorHandler()
    private var errorLogger: ErrorLogging
    private var errorPresenter: ErrorPresenting
    
    init(
        errorLogger: ErrorLogging = DefaultErrorLogger(),
        errorPresenter: ErrorPresenting = DefaultErrorPresenter()
    ) {
        self.errorLogger = errorLogger
        self.errorPresenter = errorPresenter
    }
    
    func handle(_ error: AppError) {
        logError(error)
        showError(error)
        
        // エラー種別に応じた特別な処理
        switch error {
        case .ar(.trackingStateChanged(let state)) where state == .normal:
            errorPresenter.dismissError()
        case .system(.memoryWarning):
            NotificationCenter.default.post(
                name: UIApplication.didReceiveMemoryWarningNotification,
                object: nil
            )
        default:
            break
        }
    }
    
    func recover(from error: AppError) async throws {
        switch error {
        case .ar(.trackingStateChanged):
            try await resetARSession()
        case .sensor(.calibrationRequired):
            try await calibrateSensors()
        case .system(.memoryWarning):
            try await cleanupMemory()
        default:
            // デフォルトの回復処理
            try await defaultRecovery(for: error)
        }
    }
    
    func showError(_ error: AppError) {
        errorPresenter.present(error)
    }
    
    func logError(_ error: AppError) {
        errorLogger.log(error)
    }
    
    // MARK: - Private Methods
    
    private func resetARSession() async throws {
        // ARSessionのリセット処理
    }
    
    private func calibrateSensors() async throws {
        // センサーキャリブレーション
    }
    
    private func cleanupMemory() async throws {
        // メモリクリーンアップ
    }
    
    private func defaultRecovery(for error: AppError) async throws {
        // デフォルトの回復処理
    }
}

// MARK: - Error Logging

protocol ErrorLogging {
    func log(_ error: AppError)
}

struct DefaultErrorLogger: ErrorLogging {
    func log(_ error: AppError) {
        // 実際のログ実装
        print("Error: \(error.localizedDescription)")
        if let recovery = error.recoverySuggestion {
            print("Recovery suggestion: \(recovery)")
        }
    }
}

// MARK: - Error Presenting

protocol ErrorPresenting {
    func present(_ error: AppError)
    func dismissError()
}

struct DefaultErrorPresenter: ErrorPresenting {
    func present(_ error: AppError) {
        // UI上でのエラー表示
        // 例：アラート表示など
    }
    
    func dismissError() {
        // エラー表示の消去
    }
}

================
File: Common/Extensions/SIMD4+Extensions.swift
================
import ARKit

extension SIMD4 {
    var xyz: SIMD3<Scalar> {
        SIMD3(x, y, z)
    }
}

extension SIMD3 where Scalar == Float {
    func distance(to other: SIMD3<Float>) -> Float {
        let difference = self - other
        return sqrt(difference.x * difference.x +
                    difference.y * difference.y +
                    difference.z * difference.z)
    }
}

extension ARPlaneAnchor {
    var normal: simd_float3 {
        // 垂直な壁面の場合、法線ベクトルを計算
        // transformのcolumns.2が平面の向きを示す
        transform.columns.2.xyz
    }
    
    var planeNormalAndPosition: (normal: simd_float3, position: simd_float3) {
        (normal: transform.columns.2.xyz,
         position: transform.columns.3.xyz)
    }
}

================
File: Common/Extensions/UIView+Extensions.swift
================
import UIKit

extension UIView {
    func findView<T: UIView>(of type: T.Type) -> T? {
        if let view = self as? T {
            return view
        }
        for subview in subviews {
            if let found = subview.findView(of: type) {
                return found
            }
        }
        return nil
    }
}

================
File: Common/Protocols/ErrorHandlingViewModel.swift
================
import SwiftUI
import Combine

/// エラーハンドリング機能を提供するViewModelプロトコル
protocol ErrorHandlingViewModel: ObservableObject {
    /// 現在のエラーメッセージ
    var errorMessage: String? { get set }
    
    /// エラーハンドリングサービス
    var errorHandler: ErrorHandling { get }
    
    /// エラーを処理する
    func handleError(_ error: AppError)
}

extension ErrorHandlingViewModel {
    func handleError(_ error: AppError) {
        Task { @MainActor in
            errorHandler.handle(error)
            errorMessage = error.localizedDescription
            if let recovery = error.recoverySuggestion {
                errorMessage = (errorMessage ?? "") + "\n" + recovery
            }
        }
    }
}

================
File: Common/Services/Memory/MemoryManagementDelegate.swift
================
import Foundation

protocol MemoryManagementDelegate: AnyObject {
    /// メモリ警告時の処理
    func handleMemoryWarning()
    
    /// メモリ圧迫時の処理（重要度に応じた解放）
    func handleMemoryPressure(_ pressure: MemoryPressureLevel)
    
    /// システムメモリの状態変更時の処理
    func handleSystemMemoryChange(_ status: SystemMemoryStatus)
}

enum MemoryPressureLevel {
    case low      // 通常状態
    case medium   // 中程度の圧迫
    case high     // 深刻な圧迫
    case critical // 極めて危機的
}

enum SystemMemoryStatus {
    case normal
    case warning
    case critical
}

================
File: Common/Services/Memory/MemoryManagementService.swift
================
import Foundation

@MainActor
protocol MemoryManagementService: AnyObject {
    /// メモリ管理の開始
    func startMonitoring()
    
    /// メモリ管理の停止
    func stopMonitoring()
    
    /// デリゲートの追加
    func addDelegate(_ delegate: MemoryManagementDelegate)
    
    /// デリゲートの削除
    func removeDelegate(_ delegate: MemoryManagementDelegate)
    
    /// 現在のメモリ圧迫レベルの取得
    var currentPressureLevel: MemoryPressureLevel { get }
    
    /// システムメモリの状態取得
    var systemMemoryStatus: SystemMemoryStatus { get }
}

================
File: Common/Services/Memory/MemoryManagementServiceImpl.swift
================
import Foundation
import UIKit

@MainActor
final class MemoryManagementServiceImpl: MemoryManagementService {
    private var delegates: NSHashTable<AnyObject> = .weakObjects()
    private var memoryWarningObserver: NSObjectProtocol?
    private var thermalStateObserver: NSObjectProtocol?
    
    private(set) var currentPressureLevel: MemoryPressureLevel = .low
    private(set) var systemMemoryStatus: SystemMemoryStatus = .normal
    
    init() {
        setupObservers()
    }
    
    func startMonitoring() {
        setupObservers()
    }
    
    func stopMonitoring() {
        cleanupObservers()
    }
    
    func addDelegate(_ delegate: MemoryManagementDelegate) {
        delegates.add(delegate)
    }
    
    func removeDelegate(_ delegate: MemoryManagementDelegate) {
        delegates.remove(delegate)
    }
    
    // MARK: - Private Methods
    
    private func setupObservers() {
        // メモリ警告の監視
        memoryWarningObserver = NotificationCenter.default.addObserver(
            forName: UIApplication.didReceiveMemoryWarningNotification,
            object: nil,
            queue: .main
        ) { [weak self] _ in
            Task { @MainActor [weak self] in
                await self?.handleMemoryWarning()
            }
        }
        
        // サーマル状態の監視
        if #available(iOS 16.0, *) {
            thermalStateObserver = NotificationCenter.default.addObserver(
                forName: ProcessInfo.thermalStateDidChangeNotification,
                object: nil,
                queue: .main
            ) { [weak self] _ in
                Task { @MainActor [weak self] in
                    await self?.handleThermalStateChange()
                }
            }
        }
    }
    
    private func cleanupObservers() {
        if let observer = memoryWarningObserver {
            NotificationCenter.default.removeObserver(observer)
        }
        if let observer = thermalStateObserver {
            NotificationCenter.default.removeObserver(observer)
        }
        memoryWarningObserver = nil
        thermalStateObserver = nil
    }
    
    private func handleMemoryWarning() async {
        systemMemoryStatus = .warning
        await notifyDelegates { delegate in
            delegate.handleMemoryWarning()
        }
    }
    
    @available(iOS 16.0, *)
    private func handleThermalStateChange() async {
        let state = ProcessInfo.processInfo.thermalState
        let pressureLevel: MemoryPressureLevel
        
        switch state {
        case .nominal:
            pressureLevel = .low
        case .fair:
            pressureLevel = .medium
        case .serious:
            pressureLevel = .high
        case .critical:
            pressureLevel = .critical
        @unknown default:
            pressureLevel = .low
        }
        
        currentPressureLevel = pressureLevel
        await notifyDelegates { delegate in
            delegate.handleMemoryPressure(pressureLevel)
        }
    }
    
    private func notifyDelegates(_ notification: (MemoryManagementDelegate) async -> Void) async {
        for case let delegate as MemoryManagementDelegate in delegates.allObjects {
            await notification(delegate)
        }
    }
    
    deinit {
        if let observer = memoryWarningObserver {
            NotificationCenter.default.removeObserver(observer)
        }
        if let observer = thermalStateObserver {
            NotificationCenter.default.removeObserver(observer)
        }
        memoryWarningObserver = nil
        thermalStateObserver = nil
    }
}

================
File: Common/ViewModels/BaseViewModel.swift
================
import SwiftUI
import Combine

class BaseViewModel: ObservableObject, ErrorHandlingViewModel {
    @Published var errorMessage: String?
    let errorHandler: ErrorHandling
    
    init(errorHandler: ErrorHandling = AppErrorHandler.shared) {
        self.errorHandler = errorHandler
    }
}

================
File: Features/Common/Models/ARConfigurationOptions.swift
================
import ARKit

struct ARConfigurationOptions {
    let preferredFPS: Int
    let useAntialiasing: Bool
    let frameSemantics: ARWorldTrackingConfiguration.FrameSemantics
    let showDebugOptions: Bool
    let usePersonSegmentation: Bool
    
    static func defaultOptions() -> ARConfigurationOptions {
        ARConfigurationOptions(
            preferredFPS: 60,
            useAntialiasing: true,
            frameSemantics: [.smoothedSceneDepth, .sceneDepth],
            showDebugOptions: false,
            usePersonSegmentation: true
        )
    }
    
    static func lowPerformanceOptions() -> ARConfigurationOptions {
        ARConfigurationOptions(
            preferredFPS: 30,
            useAntialiasing: false,
            frameSemantics: [],
            showDebugOptions: false,
            usePersonSegmentation: false
        )
    }
}

================
File: Features/Common/Protocols/ARConfigurationService.swift
================
import ARKit
import SceneKit

@MainActor
protocol ARConfigurationService {
    func createConfiguration() -> ARWorldTrackingConfiguration
    func getDefaultRunOptions() -> ARSession.RunOptions
    func configureView(_ view: ARSCNView)
    func updateConfiguration(_ configuration: ARWorldTrackingConfiguration)
    
#if DEBUG
    func monitorPerformance(_ session: ARSession)
#endif
}

================
File: Features/Common/Protocols/Cacheable.swift
================
import Foundation

protocol Cacheable: Actor {
    associatedtype T
    
    /// キャッシュの最大容量
    var maxItems: Int { get }
    /// クリーンアップ間隔
    var cleanupInterval: TimeInterval { get }
    
    /// アイテムの保存
    func store(_ item: T, forKey key: UUID) async throws
    
    /// アイテムの取得
    func get(forKey key: UUID) async throws -> T
    
    /// アイテムの削除
    func remove(forKey key: UUID) async throws
    
    /// キャッシュのクリーンアップを実行
    func performCleanup() async throws
}

/// キャッシュされたアイテムのメタデータ
struct CacheMetadata {
    let lastAccessed: Date
    let createdAt: Date
}

================
File: Features/Common/Services/ARConfigurationServiceImpl.swift
================
import ARKit
import SceneKit

@MainActor
final class ARConfigurationServiceImpl: ARConfigurationService {
    private let performanceMonitor: DevicePerformanceMonitor
    
    init(performanceMonitor: DevicePerformanceMonitor) {
        self.performanceMonitor = performanceMonitor
    }
    
    func createConfiguration() -> ARWorldTrackingConfiguration {
        let configuration = ARWorldTrackingConfiguration()
        let options = createOptionsForCurrentPerformance()
        
        // 基本設定
        configuration.planeDetection = ARConfigurationSettings.Core.planeDetection
        configuration.environmentTexturing = ARConfigurationSettings.Core.environmentTexturing
        configuration.frameSemantics = options.frameSemantics
        
        if ARConfigurationSettings.Features.hasAdvancedFeatures {
            configuration.isAutoFocusEnabled = true
        }
        
        if options.usePersonSegmentation {
            configuration.frameSemantics.insert(.personSegmentationWithDepth)
        }
        
        return configuration
    }
    
    func getDefaultRunOptions() -> ARSession.RunOptions {
        performanceMonitor.currentLevel == .high
        ? ARConfigurationSettings.Session.fullResetOptions
        : ARConfigurationSettings.Session.defaultResetOptions
    }
    
    func configureView(_ view: ARSCNView) {
        let options = createOptionsForCurrentPerformance()
        
        view.preferredFramesPerSecond = options.preferredFPS
        configureRendering(view, options: options)
        view.automaticallyUpdatesLighting = true
    }
    
    func updateConfiguration(_ configuration: ARWorldTrackingConfiguration) {
        let options = createOptionsForCurrentPerformance()
        configuration.frameSemantics = options.frameSemantics
        
        if options.usePersonSegmentation {
            configuration.frameSemantics.insert(.personSegmentationWithDepth)
        }
    }
    
#if DEBUG
    func monitorPerformance(_ session: ARSession) {
        guard let frame = session.currentFrame else { return }
        
        let metrics: [String: Any] = [
            "Frame Timestamp": frame.timestamp,
            "Tracking State": String(describing: frame.camera.trackingState),
            "Camera Transform": frame.camera.transform,
            "Anchor Count": frame.anchors.count
        ]
        
        print("AR Performance Metrics:", metrics)
        
        if frame.anchors.count > ARConfigurationSettings.Performance.Monitoring.maxAnchors {
            print("Warning: High anchor count (\(frame.anchors.count))")
        }
        
        if case .limited(let reason) = frame.camera.trackingState {
            print("Limited Tracking Reason: \(reason)")
        }
    }
#endif
    
    // MARK: - Private Methods
    
    private func createOptionsForCurrentPerformance() -> ARConfigurationOptions {
        let deviceSettings = ARConfigurationSettings.Device.getSpecificSettings()
        
        switch performanceMonitor.currentLevel {
        case .high:
            return ARConfigurationOptions(
                preferredFPS: ARConfigurationSettings.Performance.FrameRate.high,
                useAntialiasing: deviceSettings.preferHighPerformance,
                frameSemantics: ARConfigurationSettings.Session.FrameSemantics.high,
                showDebugOptions: false,
                usePersonSegmentation: true
            )
            
        case .medium:
            return ARConfigurationOptions(
                preferredFPS: ARConfigurationSettings.Performance.FrameRate.medium,
                useAntialiasing: false,
                frameSemantics: ARConfigurationSettings.Session.FrameSemantics.medium,
                showDebugOptions: false,
                usePersonSegmentation: true
            )
            
        case .low:
            return ARConfigurationOptions(
                preferredFPS: ARConfigurationSettings.Performance.FrameRate.low,
                useAntialiasing: false,
                frameSemantics: ARConfigurationSettings.Session.FrameSemantics.low,
                showDebugOptions: false,
                usePersonSegmentation: false
            )
        }
    }
    
    private func configureRendering(_ view: ARSCNView, options: ARConfigurationOptions) {
        guard MTLCreateSystemDefaultDevice() != nil else { return }
        
        view.antialiasingMode = options.useAntialiasing
        ? ARConfigurationSettings.Rendering.antialiasing.high
        : ARConfigurationSettings.Rendering.antialiasing.none
        
#if DEBUG
        configureDebug(view, showDebugOptions: options.showDebugOptions)
#endif
    }
    
#if DEBUG
    private func configureDebug(_ view: ARSCNView, showDebugOptions: Bool) {
        view.showsStatistics = showDebugOptions
        view.debugOptions = showDebugOptions ? ARConfigurationSettings.Rendering.debugOptions : []
    }
#endif
}

================
File: Features/Common/Services/ARConfigurationSettings.swift
================
import ARKit
import SceneKit

/// AR機能の設定を管理する構造体群
enum ARConfigurationSettings {
    // MARK: - Core Settings
    
    /// 基本セッション設定
    struct Core {
        /// 平面検出の設定
        static let planeDetection: ARWorldTrackingConfiguration.PlaneDetection = [.vertical]
        
        /// 環境テクスチャの設定
        static let environmentTexturing: ARWorldTrackingConfiguration.EnvironmentTexturing = .automatic
    }
    
    // MARK: - Session Management
    
    /// セッション管理設定
    struct Session {
        /// リセットオプション
        static let defaultResetOptions: ARSession.RunOptions = [.resetTracking, .removeExistingAnchors]
        static let fullResetOptions: ARSession.RunOptions = defaultResetOptions.union(.resetSceneReconstruction)
        
        /// フレームセマンティクス
        struct FrameSemantics {
            /// 高性能モード: シーンの深度データを処理
            static let high: ARWorldTrackingConfiguration.FrameSemantics = [.smoothedSceneDepth, .sceneDepth]
            /// 中性能モード: 平滑化された深度のみ
            static let medium: ARWorldTrackingConfiguration.FrameSemantics = [.smoothedSceneDepth]
            /// 低性能モード: 最小限の機能
            static let low: ARWorldTrackingConfiguration.FrameSemantics = []
        }
    }
    
    // MARK: - Performance Settings
    
    /// パフォーマンス関連設定
    struct Performance {
        /// フレームレート設定
        struct FrameRate {
            static let high = 60
            static let medium = 45
            static let low = 30
        }
        
        /// システムリソースのしきい値
        struct Thresholds {
            /// プロセッサ数のしきい値
            static let processor = (
                high: 6,    // 6コア以上で高性能モード
                medium: 4   // 4-5コアで中性能モード
            )
            
            /// メモリ容量のしきい値（GB単位）
            static let memory = (
                minimum: 2.0,   // 2GB未満は低性能モード
                standard: 4.0   // 4GB未満は中性能モード
            )
        }
        
        /// モニタリング設定
        struct Monitoring {
            /// アンカー数の警告しきい値
            static let maxAnchors = 30
            /// 更新間隔（秒）
            static let updateInterval: TimeInterval = 1.0
            /// 熱状態回復の待機時間（秒）
            static let thermalRecoveryDelay: TimeInterval = 5.0
        }
    }
    
    // MARK: - Rendering Settings
    
    /// レンダリング関連設定
    struct Rendering {
        /// アンチエイリアシング設定
        static let antialiasing = (
            none: SCNAntialiasingMode.none,
            high: SCNAntialiasingMode.multisampling4X
        )
        
#if DEBUG
        /// デバッグ表示オプション（デバッグビルドのみ）
        static let debugOptions: SCNDebugOptions = [.showFeaturePoints, .showWorldOrigin]
#endif
    }
    
    // MARK: - Device Specific Settings
    
    /// デバイス固有の設定
    struct Device {
        /// デバイスタイプに基づく設定を取得
        static func getSpecificSettings() -> (maxAnchors: Int, preferHighPerformance: Bool) {
            switch UIDevice.current.userInterfaceIdiom {
            case .pad:
                return (maxAnchors: 50, preferHighPerformance: true)
            default:
                return (maxAnchors: 30, preferHighPerformance: false)
            }
        }
    }
    
    // MARK: - Feature Availability
    
    /// 機能の利用可否判定
    struct Features {
        /// iOS 14以降の拡張機能が利用可能かどうか
        static var hasAdvancedFeatures: Bool {
            if #available(iOS 14.0, *) {
                return true
            }
            return false
        }
    }
}

================
File: Features/Common/Services/ARServices.swift
================
import ARKit

@MainActor
protocol ARServices: AnyObject {
    var configurationService: ARConfigurationService { get }
    func setupAR(_ view: ARSCNView)
    func lockWall(_ wall: ARPlaneAnchor) async
    func unlockWall() async
}

================
File: Features/Common/Services/ARServicesProvider.swift
================
import ARKit

@MainActor
class ARServicesProvider: ARServices {
    let configurationService: ARConfigurationService
    private let arSession: ARSession
    private var coordinator: ARSceneCoordinator?
    
    init(arSession: ARSession = ARSession(),
         configurationService: ARConfigurationService? = nil) async {
        self.arSession = arSession
        if let configService = configurationService {
            self.configurationService = configService
        } else {
            let monitor = await DevicePerformanceMonitor.create()
            self.configurationService = ARConfigurationServiceImpl(performanceMonitor: monitor)
        }
    }
    
    func setupAR(_ view: ARSCNView) {
        let configuration = configurationService.createConfiguration()
        let options = configurationService.getDefaultRunOptions()
        
        view.session.run(configuration, options: options)
        configurationService.configureView(view)
    }
    
    func setCoordinator(_ coordinator: ARSceneCoordinator) {
        self.coordinator = coordinator
    }
    
    func lockWall(_ wall: ARPlaneAnchor) async {
        await coordinator?.lockWall(with: wall.identifier)
    }
    
    func unlockWall() async {
        await coordinator?.unlockWall()
    }
}

================
File: Features/Common/Services/DevicePerformanceMonitor.swift
================
import Foundation
import UIKit
import Combine

@MainActor
final class DevicePerformanceMonitor: ObservableObject {
    @Published private(set) var currentLevel: PerformanceLevel
    private let memoryManager: MemoryManagementService
    private let updateInterval: TimeInterval
    private var updateTimer: Timer?
    
    private init(memoryManager: MemoryManagementService) {
        self.memoryManager = memoryManager
        self.currentLevel = .medium
        self.updateInterval = ARConfigurationSettings.Performance.Monitoring.updateInterval
    }
    
    static func create() async -> DevicePerformanceMonitor {
        let memoryManager = MemoryManagementServiceImpl()
        let monitor = DevicePerformanceMonitor(memoryManager: memoryManager)
        memoryManager.addDelegate(monitor)
        monitor.startMonitoring()
        return monitor
    }
    
    func startMonitoring() {
        updateTimer?.invalidate()
        updateTimer = Timer.scheduledTimer(
            withTimeInterval: updateInterval,
            repeats: true
        ) { [weak self] _ in
            Task { @MainActor [weak self] in
                await self?.updatePerformanceMetrics()
            }
        }
    }
    
    func stopMonitoring() {
        updateTimer?.invalidate()
        updateTimer = nil
    }
    
    private func updatePerformanceMetrics() async {
        let baseLevel = evaluateHardwareCapabilities()
        let adjustedLevel = await adjustForSystemConditions(baseLevel)
        
        if currentLevel != adjustedLevel {
            currentLevel = adjustedLevel
        }
    }
    
    private func evaluateHardwareCapabilities() -> PerformanceLevel {
        let processorCount = ProcessInfo.processInfo.processorCount
        let totalMemory = ProcessInfo.processInfo.physicalMemory
        let processorThresholds = ARConfigurationSettings.Performance.Thresholds.processor
        let memoryThresholds = ARConfigurationSettings.Performance.Thresholds.memory
        
        let baseLevel: PerformanceLevel
        switch processorCount {
        case processorThresholds.high...: baseLevel = .high
        case processorThresholds.medium...: baseLevel = .medium
        default: baseLevel = .low
        }
        
        let memoryGB = Double(totalMemory) / 1_000_000_000
        if memoryGB < memoryThresholds.minimum && baseLevel != .low {
            return .low
        } else if memoryGB < memoryThresholds.standard && baseLevel == .high {
            return .medium
        }
        
        let deviceSettings = ARConfigurationSettings.Device.getSpecificSettings()
        return deviceSettings.preferHighPerformance ? baseLevel : min(baseLevel, .medium)
    }
    
    private func adjustForSystemConditions(_ baseLevel: PerformanceLevel) async -> PerformanceLevel {
        switch memoryManager.systemMemoryStatus {
        case .warning:
            return baseLevel == .high ? .medium : .low
        case .critical:
            return .low
        case .normal:
            return baseLevel
        }
    }
    
    deinit {
        updateTimer?.invalidate()
        updateTimer = nil
    }
}

extension DevicePerformanceMonitor: MemoryManagementDelegate {
    nonisolated func handleMemoryWarning() {
        Task { @MainActor [weak self] in
            guard let self = self else { return }
            let adjustedLevel = await self.adjustForSystemConditions(self.currentLevel)
            if self.currentLevel != adjustedLevel {
                self.currentLevel = adjustedLevel
            }
        }
    }
    
    nonisolated func handleMemoryPressure(_ pressure: MemoryPressureLevel) {
        Task { @MainActor [weak self] in
            guard let self = self else { return }
            let adjustedLevel = await self.adjustForSystemConditions(self.currentLevel)
            if self.currentLevel != adjustedLevel {
                self.currentLevel = adjustedLevel
            }
        }
    }
    
    nonisolated func handleSystemMemoryChange(_ status: SystemMemoryStatus) {
        Task { @MainActor [weak self] in
            guard let self = self else { return }
            let adjustedLevel = await self.adjustForSystemConditions(self.currentLevel)
            if self.currentLevel != adjustedLevel {
                self.currentLevel = adjustedLevel
            }
        }
    }
}

extension DevicePerformanceMonitor {
    enum PerformanceLevel: Int, Comparable {
        case low = 0
        case medium = 1
        case high = 2
        
        static func < (lhs: PerformanceLevel, rhs: PerformanceLevel) -> Bool {
            lhs.rawValue < rhs.rawValue
        }
    }
}

================
File: Features/Common/ViewModels/ARViewModel.swift
================
import ARKit
import SwiftUI

class ARViewModel: BaseViewModel {
    @Published var trackingState: ARCamera.TrackingState?
    let arSession: ARSession
    
    init(arSession: ARSession = ARSession(),
         errorHandler: ErrorHandling = AppErrorHandler.shared) {
        self.arSession = arSession
        super.init(errorHandler: errorHandler)
    }
    
    func resetSession() {
        let configuration = ARWorldTrackingConfiguration()
        configuration.planeDetection = [.vertical]
        arSession.run(configuration, options: [.resetTracking, .removeExistingAnchors])
    }
}

================
File: Features/DistanceMeasurement/Models/DistanceData.swift
================
import Foundation

struct DistanceData {
    let distance: Float
    let isReliable: Bool
    let sensorType: SensorType
    let timestamp: Date
}

================
File: Features/DistanceMeasurement/Models/SensorType.swift
================
enum SensorType {
    case lidar
    case tof
    case ultrasonic
    
    var reliableRange: ClosedRange<Float> {
        switch self {
        case .lidar: return 0.5...5.0 // 50cm-5m
        case .tof: return 0.03...0.5  // 3cm-50cm
        case .ultrasonic: return 0.01...0.03 // 1cm-3cm
        }
    }
}

================
File: Features/DistanceMeasurement/Services/SensorManager.swift
================
import Foundation
import ARKit

protocol SensorManagerDelegate: AnyObject {
    func sensorManager(_ manager: SensorManager, didUpdateDistance distance: Float, sensorType: SensorType)
    func sensorManager(_ manager: SensorManager, didFailWithError error: Error)
}

class SensorManager {
    weak var delegate: SensorManagerDelegate?
    private var measurementTask: Task<Void, Never>?
    private var streamContinuation: AsyncStream<DistanceData>.Continuation?
    private var isRunning: Bool = false
    
    private let updateInterval: TimeInterval = 1.0 / 30.0
    private let batchSize = 5
    private var measurementBuffer: [DistanceData] = []
    private let bufferCapacity = 30
    
    private var dynamicUpdateInterval: TimeInterval
    private let minUpdateInterval: TimeInterval = 1.0 / 60.0
    private let maxUpdateInterval: TimeInterval = 1.0 / 15.0
    private var systemLoadLevel: Int = 0
    private let maxSystemLoadLevel = 5
    
    private var consecutiveErrorCount: Int = 0
    private let maxConsecutiveErrors = 3
    private var lastSuccessfulMeasurement: Date?
    private var isCalibrating = false
    
    init() {
        self.dynamicUpdateInterval = updateInterval
        setupMemoryWarningObserver()
    }
    
    func distanceStream() -> AsyncStream<DistanceData> {
        AsyncStream<DistanceData> { continuation in
            self.streamContinuation = continuation
            continuation.onTermination = { [weak self] _ in
                self?.stopMeasuring()
            }
        }
    }
    
    func startMeasuring() {
        guard !isRunning else { return }
        guard canStartMeasurement() else {
            handleError(AppError.sensor(.resourceUnavailable))
            return
        }
        
        isRunning = true
        consecutiveErrorCount = 0
        measurementBuffer.reserveCapacity(bufferCapacity)
        
        measurementTask = Task { [weak self] in
            guard let self = self else { return }
            
            do {
                try await self.initializeSensor()
                
                while !Task.isCancelled && self.isRunning {
                    if await self.shouldPerformCalibration() && !self.isCalibrating {
                        self.isCalibrating = true
                        try await self.performCalibration()
                        self.isCalibrating = false
                    }
                    
                    try await self.processMeasurements()
                    try await self.adjustedSleep()
                }
            } catch {
                if let appError = error as? AppError {
                    self.handleError(appError)
                } else {
                    self.handleError(AppError.sensor(.measurementError(error.localizedDescription)))
                }
            }
            
            self.streamContinuation?.finish()
        }
    }
    
    func stopMeasuring() {
        isRunning = false
        measurementTask?.cancel()
        measurementTask = nil
        streamContinuation?.finish()
        streamContinuation = nil
        measurementBuffer.removeAll(keepingCapacity: true)
    }
    
    private func processMeasurements() async throws {
        for _ in 0..<batchSize {
            if Task.isCancelled || !isRunning { break }
            
            let measurement = try await performSingleMeasurement()
            measurementBuffer.append(measurement)
            
            if measurementBuffer.count >= bufferCapacity {
                await flushMeasurements()
            }
        }
        
        if !measurementBuffer.isEmpty {
            await flushMeasurements()
        }
    }
    
    private func performSingleMeasurement() async throws -> DistanceData {
        if systemLoadLevel >= maxSystemLoadLevel {
            throw AppError.sensor(.systemOverload)
        }
        
        let dummyDistance = Float.random(in: 0.5...5.0)
        
        let distanceData = DistanceData(
            distance: dummyDistance,
            isReliable: true,
            sensorType: .lidar,
            timestamp: Date()
        )
        
        lastSuccessfulMeasurement = Date()
        consecutiveErrorCount = 0
        return distanceData
    }
    
    private func flushMeasurements() async {
        guard !measurementBuffer.isEmpty else { return }
        
        let latestMeasurement = measurementBuffer.last!
        delegate?.sensorManager(self,
                                didUpdateDistance: latestMeasurement.distance,
                                sensorType: latestMeasurement.sensorType)
        
        for measurement in measurementBuffer {
            streamContinuation?.yield(measurement)
        }
        
        measurementBuffer.removeAll(keepingCapacity: true)
    }
    
    private func adjustedSleep() async throws {
        let interval = min(max(dynamicUpdateInterval * Double(systemLoadLevel + 1),
                               minUpdateInterval),
                           maxUpdateInterval)
        try await Task.sleep(nanoseconds: UInt64(interval * 1_000_000_000))
    }
    
    private func setupMemoryWarningObserver() {
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(handleMemoryWarning),
            name: UIApplication.didReceiveMemoryWarningNotification,
            object: nil
        )
    }
    
    @objc private func handleMemoryWarning() {
        systemLoadLevel = maxSystemLoadLevel
        measurementBuffer.removeAll(keepingCapacity: true)
    }
    
    private func initializeSensor() async throws {
        if arc4random_uniform(100) < 5 {
            throw AppError.sensor(.initializationFailed)
        }
    }
    
    private func shouldPerformCalibration() async -> Bool {
        guard let lastMeasurement = lastSuccessfulMeasurement else { return true }
        return Date().timeIntervalSince(lastMeasurement) > 300
    }
    
    private func performCalibration() async throws {
        if arc4random_uniform(100) < 10 {
            throw AppError.sensor(.calibrationRequired)
        }
    }
    
    private func canStartMeasurement() -> Bool {
        return true
    }
    
    private func handleError(_ error: AppError) {
        delegate?.sensorManager(self, didFailWithError: error)
        
        switch error {
        case .sensor(let sensorError):
            switch sensorError {
            case .initializationFailed, .resourceUnavailable, .consecutiveErrors:
                stopMeasuring()
            case .systemOverload:
                if consecutiveErrorCount >= maxConsecutiveErrors {
                    stopMeasuring()
                }
            case .calibrationRequired, .measurementError, .dataInvalid:
                consecutiveErrorCount += 1
                if consecutiveErrorCount >= maxConsecutiveErrors {
                    stopMeasuring()
                }
            }
        default:
            break
        }
    }
    
    deinit {
        NotificationCenter.default.removeObserver(self)
        stopMeasuring()
    }
}
