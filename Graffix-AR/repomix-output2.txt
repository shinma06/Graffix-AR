This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-03T13:58:23.024Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
App/
  Graffix-ARApp.swift
  Info.plist
Assets/
  Assets.xcassets/
    AccentColor.colorset/
      Contents.json
    AppIcon.appiconset/
      Contents.json
    Contents.json
  Preview Content/
    Preview Assets.xcassets/
      Contents.json
Common/
  Cache/
    BaseCache.swift
    CacheError.swift
  Errors/
    AppError.swift
    ErrorHandling.swift
  Extensions/
    SIMD4+Extensions.swift
    UIView+Extensions.swift
  Protocols/
    ErrorHandlingViewModel.swift
  Services/
    Memory/
      MemoryManagementDelegate.swift
      MemoryManagementService.swift
      MemoryManagementServiceImpl.swift
  ViewModels/
    BaseViewModel.swift
Features/
  Common/
    Models/
      ARConfigurationOptions.swift
    Protocols/
      ARConfigurationService.swift
      Cacheable.swift
    Services/
      ARConfigurationServiceImpl.swift
      ARConfigurationSettings.swift
      ARServices.swift
      ARServicesProvider.swift
      DevicePerformanceMonitor.swift
    ViewModels/
      ARViewModel.swift
  DistanceMeasurement/
    Models/
      DistanceData.swift
      SensorType.swift
    Services/
      SensorManager.swift
    ViewModels/
      DistanceViewModel.swift
      MeasurementViewModel.swift
  WallDetection/
    Models/
      WallDetectionEvent.swift
      WallDetectionMode.swift
    Services/
      WallDetectionService.swift
      WallDistanceTracker.swift
    ViewModels/
      WallDetectionViewModel.swift
      WallTargetingViewModel.swift
    Views/
      ARView/
        Coordinators/
          ARSceneCoordinator.swift
        Rendering/
          PlaneNodeCache.swift
          PlaneNodeFactory.swift
          PlaneNodeUpdater.swift
        WallManagement/
          WallColorManager.swift
          WallGroupCache.swift
          WallGroupManager.swift
        ARMainContentView.swift
        ARViewContainer.swift
      Components/
        ReticuleMark.swift
        WallDetectionOverlay.swift
        WallIndicator.swift
      MainView.swift
Resources/
  Localization/
    ja.lproj/
      Localizable.strings

================================================================
Files
================================================================

================
File: Features/DistanceMeasurement/ViewModels/DistanceViewModel.swift
================
import ARKit
import SwiftUI

final class DistanceViewModel: BaseViewModel {
    @Published private(set) var currentDistance: DistanceData?
    private let sensorManager: SensorManager
    private let arSession: ARSession
    
    init(sensorManager: SensorManager = SensorManager(),
         arSession: ARSession = ARSession(),
         errorHandler: ErrorHandling = AppErrorHandler.shared) {
        self.sensorManager = sensorManager
        self.arSession = arSession
        super.init(errorHandler: errorHandler)
        setupDelegates()
    }
    
    private func setupDelegates() {
        sensorManager.delegate = self
    }
    
    func startMeasurement() {
        sensorManager.startMeasuring()
        errorMessage = nil
    }
    
    func stopMeasurement() {
        sensorManager.stopMeasuring()
    }
    
    deinit {
        stopMeasurement()
    }
}

// MARK: - SensorManagerDelegate
extension DistanceViewModel: SensorManagerDelegate {
    nonisolated func sensorManager(_ manager: SensorManager, didUpdateDistance distance: Float, sensorType: SensorType) {
        let isReliable = sensorType.reliableRange.contains(distance)
        Task { @MainActor in
            self.currentDistance = DistanceData(
                distance: distance,
                isReliable: isReliable,
                sensorType: sensorType,
                timestamp: Date()
            )
        }
    }
    
    nonisolated func sensorManager(_ manager: SensorManager, didFailWithError error: Error) {
        Task { @MainActor in
            if let appError = error as? AppError {
                self.handleError(appError)
            } else {
                self.handleError(.system(.unexpectedState(error.localizedDescription)))
            }
        }
    }
}

================
File: Features/DistanceMeasurement/ViewModels/MeasurementViewModel.swift
================
import ARKit
import SwiftUI
import Combine

final class MeasurementViewModel: BaseViewModel {
    @Published private(set) var currentDistance: DistanceData?
    @Published var detectedWalls: [ARPlaneAnchor]
    
    let wallDetectionViewModel: WallDetectionViewModel
    private let distanceViewModel: DistanceViewModel
    private let arServices: ARServices
    private var cancellables = Set<AnyCancellable>()
    
    var trackingState: ARCamera.TrackingState? { wallDetectionViewModel.trackingState }
    var detectionMode: WallDetectionMode { wallDetectionViewModel.detectionMode }
    
    init(distanceViewModel: DistanceViewModel = DistanceViewModel(),
         wallDetectionViewModel: WallDetectionViewModel = WallDetectionViewModel(
            wallDetectionService: WallDetectionService(arSession: ARSession())),
         arServices: ARServices,
         errorHandler: ErrorHandling = AppErrorHandler.shared) {
        self.distanceViewModel = distanceViewModel
        self.wallDetectionViewModel = wallDetectionViewModel
        self.arServices = arServices
        self.detectedWalls = []
        super.init(errorHandler: errorHandler)
        
        setupErrorMessageBinding()
        setupDistanceBinding()
        setupWallsBinding()
    }
    
    private func setupErrorMessageBinding() {
        distanceViewModel.objectWillChange.sink { [weak self] in
            if let error = self?.distanceViewModel.errorMessage {
                self?.errorMessage = error
            }
        }.store(in: &cancellables)
        
        wallDetectionViewModel.objectWillChange.sink { [weak self] in
            if let error = self?.wallDetectionViewModel.errorMessage {
                self?.errorMessage = error
            }
        }.store(in: &cancellables)
    }
    
    private func setupDistanceBinding() {
        distanceViewModel.$currentDistance
            .assign(to: \.currentDistance, on: self)
            .store(in: &cancellables)
    }
    
    private func setupWallsBinding() {
        wallDetectionViewModel.$detectedWalls
            .assign(to: \.detectedWalls, on: self)
            .store(in: &cancellables)
    }
    
    func startMeasurement() {
        distanceViewModel.startMeasurement()
    }
    
    func stopMeasurement() {
        distanceViewModel.stopMeasurement()
    }
    
    func lockToWall(_ wall: ARPlaneAnchor) async {
        await arServices.lockWall(wall)
    }
    
    func unlockWall() async {
        await arServices.unlockWall()
    }
    
    deinit {
        cancellables.removeAll()
    }
}

================
File: Features/WallDetection/Models/WallDetectionEvent.swift
================
import ARKit

enum WallDetectionEvent {
    case wallsUpdated([ARPlaneAnchor])
    case wallLocked(ARPlaneAnchor)
    case wallUnlocked
    case trackingStateChanged(ARCamera.TrackingState)
    case sessionInterrupted
    case sessionResumes
    case error(AppError)
    
    var priority: EventPriority {
        switch self {
        case .error: return .high
        case .trackingStateChanged, .wallLocked, .wallUnlocked: return .medium
        case .wallsUpdated, .sessionInterrupted, .sessionResumes: return .low
        }
    }
}

enum EventPriority: Int, Comparable {
    case high = 0
    case medium = 1
    case low = 2
    
    static func < (lhs: EventPriority, rhs: EventPriority) -> Bool {
        lhs.rawValue < rhs.rawValue
    }
}

struct EventWrapper {
    let event: WallDetectionEvent
    let timestamp: Date
    
    var isExpired: Bool {
        Date().timeIntervalSince(timestamp) > 5.0
    }
}

================
File: Features/WallDetection/Models/WallDetectionMode.swift
================
enum WallDetectionMode {
    case free
    case locked
}

================
File: Features/WallDetection/Services/WallDetectionService.swift
================
import ARKit
import Foundation

protocol WallDetectionServiceDelegate: AnyObject {
    func wallDetectionService(_ service: WallDetectionService, didUpdateWalls walls: [ARPlaneAnchor]) async
    func wallDetectionService(_ service: WallDetectionService, didLockToWall wall: ARPlaneAnchor) async
    func wallDetectionServiceDidUnlock(_ service: WallDetectionService) async
    func wallDetectionService(_ service: WallDetectionService, didFailWithError error: AppError) async
}

@globalActor actor WallDetectionServiceActor {
    static let shared = WallDetectionServiceActor()
}

class WallDetectionService: NSObject, ARSessionDelegate {
    weak var delegate: WallDetectionServiceDelegate?
    private let arSession: ARSession
    private var currentWall: ARPlaneAnchor?
    private var isProcessingUpdate = false
    
    private var eventContinuation: AsyncStream<WallDetectionEvent>.Continuation?
    private var eventBuffer: [EventWrapper] = []
    private let maxBufferSize = 30
    private var eventProcessingTask: Task<Void, Never>?
    
    init(arSession: ARSession, delegate: WallDetectionServiceDelegate? = nil) {
        self.arSession = arSession
        self.delegate = delegate
        super.init()
        self.arSession.delegate = self
        setupEventProcessing()
    }
    
    func events() -> AsyncStream<WallDetectionEvent> {
        AsyncStream { continuation in
            self.eventContinuation = continuation
            continuation.onTermination = { [weak self] _ in
                self?.cleanupEventProcessing()
            }
        }
    }
    
    @WallDetectionServiceActor
    func detectWalls() async -> [ARPlaneAnchor] {
        guard let currentFrame = arSession.currentFrame else { return [] }
        
        let walls = currentFrame.anchors.compactMap { anchor -> ARPlaneAnchor? in
            guard let planeAnchor = anchor as? ARPlaneAnchor,
                  planeAnchor.alignment == .vertical else {
                return nil
            }
            return planeAnchor
        }
        
        queueEvent(.wallsUpdated(walls))
        return walls
    }
    
    @WallDetectionServiceActor
    func lockToWall(_ wall: ARPlaneAnchor) async {
        currentWall = wall
        queueEvent(.wallLocked(wall))
        await delegate?.wallDetectionService(self, didLockToWall: wall)
    }
    
    @WallDetectionServiceActor
    func unlockWall() async {
        currentWall = nil
        queueEvent(.wallUnlocked)
        await delegate?.wallDetectionServiceDidUnlock(self)
    }
    
    // MARK: - ARSessionDelegate
    
    func session(_ session: ARSession, didFailWithError error: Error) {
        Task { @WallDetectionServiceActor in
            await handleSessionError(error)
        }
    }
    
    func session(_ session: ARSession, cameraDidChangeTrackingState camera: ARCamera) {
        Task { @WallDetectionServiceActor in
            await handleTrackingStateChange(camera.trackingState)
        }
    }
    
    func session(_ session: ARSession, didUpdate frame: ARFrame) {
        Task { @WallDetectionServiceActor in
            await processFrame(frame)
        }
    }
    
    // MARK: - Private Methods
    
    private func setupEventProcessing() {
        eventProcessingTask = Task { [weak self] in
            while !Task.isCancelled {
                try? await Task.sleep(nanoseconds: UInt64(1.0 / 30.0 * 1_000_000_000))
                await self?.processEventBuffer()
            }
        }
    }
    
    @WallDetectionServiceActor
    private func processEventBuffer() async {
        eventBuffer.removeAll { $0.isExpired }
        
        if eventBuffer.count > maxBufferSize {
            eventBuffer.sort { $0.event.priority < $1.event.priority }
            eventBuffer = Array(eventBuffer.prefix(maxBufferSize))
        }
        
        for wrapper in eventBuffer {
            eventContinuation?.yield(wrapper.event)
        }
        eventBuffer.removeAll()
    }
    
    @WallDetectionServiceActor
    private func queueEvent(_ event: WallDetectionEvent) {
        let wrapper = EventWrapper(event: event, timestamp: Date())
        eventBuffer.append(wrapper)
    }
    
    private func cleanupEventProcessing() {
        eventProcessingTask?.cancel()
        eventProcessingTask = nil
        eventBuffer.removeAll()
    }
    
    @WallDetectionServiceActor
    private func handleSessionError(_ error: Error) async {
        let appError = AppError.ar(.sessionFailed(error))
        queueEvent(.error(appError))
        await delegate?.wallDetectionService(self, didFailWithError: appError)
    }
    
    @WallDetectionServiceActor
    private func handleTrackingStateChange(_ state: ARCamera.TrackingState) async {
        queueEvent(.trackingStateChanged(state))
        
        switch state {
        case .normal:
            break
        case .notAvailable:
            await delegate?.wallDetectionService(self, didFailWithError: .ar(.trackingStateChanged(state)))
        case .limited(let reason):
            await delegate?.wallDetectionService(self, didFailWithError: .ar(.trackingStateChanged(.limited(reason))))
        }
    }
    
    @WallDetectionServiceActor
    private func processFrame(_ frame: ARFrame) async {
        guard !isProcessingUpdate else { return }
        isProcessingUpdate = true
        defer { isProcessingUpdate = false }
        
        let walls = frame.anchors.compactMap { anchor -> ARPlaneAnchor? in
            guard let planeAnchor = anchor as? ARPlaneAnchor,
                  planeAnchor.alignment == .vertical else {
                return nil
            }
            return planeAnchor
        }
        
        queueEvent(.wallsUpdated(walls))
        await delegate?.wallDetectionService(self, didUpdateWalls: walls)
    }
    
    deinit {
        cleanupEventProcessing()
    }
}

================
File: Features/WallDetection/Services/WallDistanceTracker.swift
================


================
File: Features/WallDetection/ViewModels/WallDetectionViewModel.swift
================
import ARKit
import SwiftUI

final class WallDetectionViewModel: BaseViewModel {
    @Published var detectionMode: WallDetectionMode = .free
    @Published var detectedWalls: [ARPlaneAnchor] = []
    @Published var trackingState: ARCamera.TrackingState?
    
    private let wallDetectionService: WallDetectionService
    private var eventProcessingTask: Task<Void, Never>?
    private var wallUpdateDebouncer: Task<Void, Never>?
    private let wallUpdateInterval: TimeInterval = 0.1
    
    init(wallDetectionService: WallDetectionService,
         arSession: ARSession = ARSession(),
         errorHandler: ErrorHandling = AppErrorHandler.shared) {
        self.wallDetectionService = wallDetectionService
        super.init(errorHandler: errorHandler)
        setupDelegates()
        setupEventProcessing()
    }
    
    private func setupDelegates() {
        wallDetectionService.delegate = self
    }
    
    private func setupEventProcessing() {
        eventProcessingTask = Task { [weak self] in
            guard let self = self else { return }
            
            for await event in wallDetectionService.events() {
                if Task.isCancelled { break }
                await self.processWallDetectionEvent(event)
            }
        }
    }
    
    private func processWallDetectionEvent(_ event: WallDetectionEvent) async {
        switch event {
        case .wallsUpdated(let walls):
            wallUpdateDebouncer?.cancel()
            wallUpdateDebouncer = Task { [weak self] in
                try? await Task.sleep(nanoseconds: UInt64(self?.wallUpdateInterval ?? 0.1 * 1_000_000_000))
                await self?.handleWallsUpdate(walls)
            }
            
        case .wallLocked(let wall):
            detectionMode = .locked
            if let index = detectedWalls.firstIndex(where: { $0.identifier == wall.identifier }) {
                detectedWalls[index] = wall
            }
            
        case .wallUnlocked:
            detectionMode = .free
            
        case .trackingStateChanged(let state):
            trackingState = state
            handleTrackingStateChange(state)
            
        case .sessionInterrupted:
            errorMessage = "ARセッションが中断されました"
            
        case .sessionResumes:
            errorMessage = nil
            
        case .error(let error):
            handleError(error)
        }
    }
    
    private func handleWallsUpdate(_ walls: [ARPlaneAnchor]) async {
        guard detectionMode == .free else { return }
        
        var updatedWalls = detectedWalls
        for wall in walls {
            if let index = updatedWalls.firstIndex(where: { $0.identifier == wall.identifier }) {
                updatedWalls[index] = wall
            } else {
                updatedWalls.append(wall)
            }
        }
        
        updatedWalls.removeAll { wall in
            !walls.contains { $0.identifier == wall.identifier }
        }
        
        detectedWalls = updatedWalls
    }
    
    private func handleTrackingStateChange(_ state: ARCamera.TrackingState) {
        switch state {
        case .normal:
            errorMessage = nil
        case .limited(let reason):
            let error = AppError.ar(.trackingStateChanged(.limited(reason)))
            handleError(error)
        case .notAvailable:
            let error = AppError.ar(.trackingStateChanged(.notAvailable))
            handleError(error)
        }
    }
    
    deinit {
        eventProcessingTask?.cancel()
        wallUpdateDebouncer?.cancel()
    }
}

// MARK: - WallDetectionServiceDelegate
extension WallDetectionViewModel: WallDetectionServiceDelegate {
    nonisolated func wallDetectionService(_ service: WallDetectionService, didUpdateWalls walls: [ARPlaneAnchor]) async {
        await MainActor.run {
            if self.detectionMode == .free {
                self.detectedWalls = walls
            }
        }
    }
    
    nonisolated func wallDetectionService(_ service: WallDetectionService, didLockToWall wall: ARPlaneAnchor) async {
        await MainActor.run {
            self.detectionMode = .locked
        }
    }
    
    nonisolated func wallDetectionServiceDidUnlock(_ service: WallDetectionService) async {
        await MainActor.run {
            self.detectionMode = .free
        }
    }
    
    nonisolated func wallDetectionService(_ service: WallDetectionService, didFailWithError error: AppError) async {
        await MainActor.run {
            self.handleError(error)
        }
    }
}

================
File: Features/WallDetection/ViewModels/WallTargetingViewModel.swift
================
import SwiftUI
import ARKit
import Combine

@MainActor
class WallTargetingViewModel: ObservableObject {
    enum TargetingState {
        case searching
        case targeting
        case locked
    }
    
    @Published private(set) var targetingState: TargetingState = .searching
    @Published private(set) var currentDistance: Float?
    @Published var errorMessage: String?
    
    private var targetedWall: ARPlaneAnchor?
    private weak var arSceneCoordinator: ARSceneCoordinator?
    
    // 非固定時は距離を表示しない
    func updateTargetedWall(_ wall: ARPlaneAnchor, distance: Float) {
        if targetingState == .locked {
            // 固定モード時は距離を更新
            if let lockedWall = targetedWall,
               wall.identifier == lockedWall.identifier {
                currentDistance = distance
            }
        } else {
            targetedWall = wall
            targetingState = .targeting
            // 非固定時は距離を表示しない
            currentDistance = nil
        }
    }
    
    // 壁面固定処理
    func lockWall() async {
        guard let wall = targetedWall else { return }
        guard let coordinator = arSceneCoordinator else { return }
        
        // 固定状態に移行
        targetingState = .locked
        // ARSceneCoordinatorに固定を通知
        await coordinator.lockWall(with: wall.identifier)
        // 固定後の距離測定開始
        startDistanceMeasurement()
    }
    
    // 固定解除処理
    func unlockWall() {
        guard let coordinator = arSceneCoordinator else { return }
        
        targetingState = .searching
        targetedWall = nil
        currentDistance = nil
        
        Task {
            await coordinator.unlockWall()
        }
    }
    
    // 固定時の距離測定
    private func startDistanceMeasurement() {
        // 距離測定ロジックは今後実装
        // 現状は仮の実装として、updateTargetedWallで更新される距離を表示
        if targetingState == .locked {
            // currentDistanceの更新を許可
        }
    }
    
    func setCoordinator(_ coordinator: ARSceneCoordinator) {
        arSceneCoordinator = coordinator
    }
    
    func clearTarget() {
        if targetingState != .locked {
            targetedWall = nil
            currentDistance = nil
            targetingState = .searching
        }
    }
}

================
File: Features/WallDetection/Views/ARView/Coordinators/ARSceneCoordinator.swift
================
import ARKit
import SceneKit
import SwiftUI

class ARSceneCoordinator: NSObject, ARSCNViewDelegate, ARSessionDelegate {
    let arViewHolder = ARViewHolder()
    private let parent: ARViewContainer
    private let wallGroupManager: WallGroupManager
    private let planeNodeCache: PlaneNodeCache
    private var lockedWallID: UUID?
    private var renderTasks: [UUID: Task<Void, Never>] = [:]
    private var cleanupTask: Task<Void, Never>?
    private let wallTargetingVM: WallTargetingViewModel
    private var intersectionCheckTask: Task<Void, Never>?
    
    init(_ parent: ARViewContainer, wallTargetingVM: WallTargetingViewModel) {
        self.parent = parent
        self.wallGroupManager = WallGroupManager()
        self.planeNodeCache = PlaneNodeCache()
        self.wallTargetingVM = wallTargetingVM
        super.init()
        
        Task {
            do {
                try await planeNodeCache.initialize()
            } catch {
                await handleError(error)
            }
        }
        
        setupTasks()
        setupMemoryWarningObserver()
    }
    
    private func setupTasks() {
        setupCleanupTask()
        setupIntersectionCheck()
    }
    
    private func setupCleanupTask() {
        cleanupTask = Task { [weak self] in
            while !Task.isCancelled {
                guard let self = self else { break }
                do {
                    try await Task.sleep(nanoseconds: UInt64(30 * 1_000_000_000))
                    await self.performCleanup()
                } catch {
                    if !Task.isCancelled {
                        await self.handleError(error)
                    }
                }
            }
        }
    }
    
    private func setupIntersectionCheck() {
        intersectionCheckTask = Task { [weak self] in
            while !Task.isCancelled {
                guard let self = self else { break }
                await self.checkIntersection()
                try? await Task.sleep(nanoseconds: UInt64(1.0 / 30.0 * 1_000_000_000))
            }
        }
    }
    
    private func checkIntersection() async {
        guard let arView = arViewHolder.view else { return }
        
        let bounds = await arView.bounds
        let viewCenter = CGPoint(
            x: bounds.width / 2,
            y: bounds.height / 2
        )
        
        if let result = await performRaycast(from: viewCenter, in: arView),
           let anchor = result.anchor as? ARPlaneAnchor {
            let distance = simd_length(result.worldTransform.columns.3.xyz)
            await wallTargetingVM.updateTargetedWall(anchor, distance: distance)
        } else {
            await wallTargetingVM.clearTarget()
        }
    }
    
    private func performRaycast(from point: CGPoint, in view: ARSCNView) async -> ARRaycastResult? {
        await MainActor.run {
            guard let query = view.raycastQuery(
                from: point,
                allowing: .existingPlaneGeometry,
                alignment: .vertical
            ) else { return nil }
            
            return view.session.raycast(query).first
        }
    }
    
    func renderer(_ renderer: SCNSceneRenderer, didAdd node: SCNNode, for anchor: ARAnchor) {
        guard let planeAnchor = anchor as? ARPlaneAnchor else { return }
        
        let taskID = planeAnchor.identifier
        renderTasks[taskID]?.cancel()
        renderTasks[taskID] = Task { [weak self] in
            guard let self = self else { return }
            do {
                if let lockedID = self.lockedWallID {
                    let detectedWalls = await MainActor.run { self.parent.viewModel.detectedWalls }
                    if let lockedWall = detectedWalls.first(where: { $0.identifier == lockedID }) {
                        let isInSameGroup = await self.wallGroupManager.isInSameGroup(planeAnchor, as: lockedWall)
                        if isInSameGroup {
                            let groupID = try await self.wallGroupManager.addWall(planeAnchor)
                            let color = await self.wallGroupManager.getColor(for: groupID)
                            let planeNode = PlaneNodeFactory.createPlaneNode(for: planeAnchor, color: color)
                            
                            await MainActor.run {
                                node.addChildNode(planeNode)
                            }
                            
                            try await self.planeNodeCache.store(identifier: planeAnchor.identifier, node: planeNode)
                        }
                    }
                } else {
                    let groupID = try await self.wallGroupManager.addWall(planeAnchor)
                    await updateDetectedWalls { walls in
                        walls.append(planeAnchor)
                    }
                    
                    let color = await self.wallGroupManager.getColor(for: groupID)
                    let planeNode = PlaneNodeFactory.createPlaneNode(for: planeAnchor, color: color)
                    
                    await MainActor.run {
                        node.addChildNode(planeNode)
                    }
                    
                    try await self.planeNodeCache.store(identifier: planeAnchor.identifier, node: planeNode)
                }
            } catch {
                if !Task.isCancelled {
                    await self.handleError(error)
                }
            }
        }
    }
    
    func renderer(_ renderer: SCNSceneRenderer, didUpdate node: SCNNode, for anchor: ARAnchor) {
        guard let planeAnchor = anchor as? ARPlaneAnchor else { return }
        
        let taskID = planeAnchor.identifier
        renderTasks[taskID]?.cancel()
        renderTasks[taskID] = Task { [weak self] in
            guard let self = self else { return }
            do {
                if let lockedID = self.lockedWallID {
                    let detectedWalls = await MainActor.run { self.parent.viewModel.detectedWalls }
                    if let lockedWall = detectedWalls.first(where: { $0.identifier == lockedID }) {
                        let isInSameGroup = await self.wallGroupManager.isInSameGroup(planeAnchor, as: lockedWall)
                        if isInSameGroup {
                            let groupID = try await self.wallGroupManager.addWall(planeAnchor)
                            let color = await self.wallGroupManager.getColor(for: groupID)
                            
                            let planeNode = try await self.planeNodeCache.getNode(for: planeAnchor.identifier)
                            await MainActor.run {
                                PlaneNodeUpdater.updatePlaneNode(planeNode, with: planeAnchor)
                                planeNode.geometry?.firstMaterial?.diffuse.contents = color
                            }
                        }
                    }
                } else {
                    let groupID = try await self.wallGroupManager.addWall(planeAnchor)
                    let color = await self.wallGroupManager.getColor(for: groupID)
                    
                    let planeNode = try await self.planeNodeCache.getNode(for: planeAnchor.identifier)
                    await MainActor.run {
                        PlaneNodeUpdater.updatePlaneNode(planeNode, with: planeAnchor)
                        planeNode.geometry?.firstMaterial?.diffuse.contents = color
                    }
                    
                    await updateDetectedWalls { walls in
                        if let index = walls.firstIndex(where: { $0.identifier == planeAnchor.identifier }) {
                            walls[index] = planeAnchor
                        }
                    }
                }
            } catch {
                if !Task.isCancelled {
                    await self.handleError(error)
                }
            }
        }
    }
    
    func renderer(_ renderer: SCNSceneRenderer, didRemove node: SCNNode, for anchor: ARAnchor) {
        guard let planeAnchor = anchor as? ARPlaneAnchor else { return }
        
        let taskID = planeAnchor.identifier
        renderTasks[taskID]?.cancel()
        renderTasks[taskID] = Task { [weak self] in
            guard let self = self else { return }
            do {
                if let lockedID = self.lockedWallID, planeAnchor.identifier == lockedID {
                    return
                }
                
                await updateDetectedWalls { walls in
                    walls.removeAll { $0.identifier == planeAnchor.identifier }
                }
                
                try await self.planeNodeCache.remove(identifier: planeAnchor.identifier)
                await self.wallGroupManager.removeWall(planeAnchor)
            } catch {
                if !Task.isCancelled {
                    await self.handleError(error)
                }
            }
        }
    }
    
    private func handleError(_ error: Error) async {
        await MainActor.run {
            if let appError = error as? AppError {
                parent.viewModel.handleError(appError)
            } else {
                parent.viewModel.handleError(.system(.unexpectedState(error.localizedDescription)))
            }
        }
    }
    
    private func updateDetectedWalls(_ update: (inout [ARPlaneAnchor]) -> Void) async {
        await MainActor.run {
            var walls = parent.viewModel.detectedWalls
            update(&walls)
            parent.viewModel.detectedWalls = walls
        }
    }
    
    private func setupMemoryWarningObserver() {
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(handleMemoryWarning),
            name: UIApplication.didReceiveMemoryWarningNotification,
            object: nil
        )
    }
    
    @objc private func handleMemoryWarning() {
        if lockedWallID == nil {
            Task {
                await performCleanup()
            }
        }
    }
    
    private func performCleanup() async {
        guard lockedWallID == nil else { return }
        
        let unusedNodes = await planeNodeCache.getUnusedNodes()
        for identifier in unusedNodes {
            do {
                try await planeNodeCache.remove(identifier: identifier)
            } catch {
                await handleError(error)
            }
        }
    }
    
    deinit {
        NotificationCenter.default.removeObserver(self)
        renderTasks.values.forEach { $0.cancel() }
        renderTasks.removeAll()
        cleanupTask?.cancel()
        intersectionCheckTask?.cancel()
    }
    
    func lockWall(with identifier: UUID) async {
        let detectedWalls = await MainActor.run { parent.viewModel.detectedWalls }
        guard let targetWall = detectedWalls.first(where: { $0.identifier == identifier }) else { return }
        
        self.lockedWallID = identifier
        
        for wall in detectedWalls where wall.identifier != identifier {
            try? await planeNodeCache.remove(identifier: wall.identifier)
            await wallGroupManager.removeWall(wall)
        }
        
        await updateDetectedWalls { walls in
            walls = [targetWall]
        }
        
        guard let arView = arViewHolder.view else { return }
        let configuration = ARWorldTrackingConfiguration()
        configuration.planeDetection = [.vertical]
        await arView.session.run(configuration, options: [])
    }
    
    func unlockWall() async {
        self.lockedWallID = nil
        
        let detectedWalls = await MainActor.run { parent.viewModel.detectedWalls }
        
        for wall in detectedWalls {
            try? await planeNodeCache.remove(identifier: wall.identifier)
            await wallGroupManager.removeWall(wall)
        }
        
        await updateDetectedWalls { walls in
            walls.removeAll()
        }
        
        guard let arView = arViewHolder.view else { return }
        let configuration = ARWorldTrackingConfiguration()
        configuration.planeDetection = [.vertical]
        await arView.session.run(
            configuration,
            options: [.resetTracking, .removeExistingAnchors]
        )
    }
}

================
File: Features/WallDetection/Views/ARView/Rendering/PlaneNodeCache.swift
================
import SceneKit

actor PlaneNodeCache {
    private let cache: BaseCache<SCNNode>
    private let unusedThreshold: TimeInterval
    private let emergencyThreshold: Int
    
    init(maxNodes: Int = 30, cleanupInterval: TimeInterval = 15) {
        self.cache = BaseCache<SCNNode>(maxItems: maxNodes, cleanupInterval: cleanupInterval)
        self.unusedThreshold = 30
        self.emergencyThreshold = Int(Double(maxNodes) * 0.9)
    }
    
    func initialize() async throws {
        try await cache.initialize()
    }
    
    func store(identifier: UUID, node: SCNNode) async throws {
        if await cache.count >= emergencyThreshold {
            try await cache.performEmergencyCleanup()
        }
        try await cache.store(node, forKey: identifier)
    }
    
    func getNode(for identifier: UUID) async throws -> SCNNode {
        try await cache.get(forKey: identifier)
    }
    
    func remove(identifier: UUID) async throws {
        let node = try await cache.get(forKey: identifier)
        await MainActor.run {
            node.removeFromParentNode()
        }
        try await cache.remove(forKey: identifier)
    }
    
    func getUnusedNodes(threshold: TimeInterval = 30) async -> [UUID] {
        let now = Date()
        let keys = await cache.keys
        
        var unusedKeys: [UUID] = []
        for key in keys {
            if let metadata = try? await cache.getMetadata(for: key),
               now.timeIntervalSince(metadata.lastAccessed) > threshold {
                unusedKeys.append(key)
            }
        }
        return unusedKeys
    }
    
    deinit {
        // BaseCacheのdeinitが自動的に呼ばれる
    }
}

================
File: Features/WallDetection/Views/ARView/Rendering/PlaneNodeFactory.swift
================
import SceneKit
import ARKit

class PlaneNodeFactory {
    static func createPlaneNode(for anchor: ARPlaneAnchor, color: UIColor) -> SCNNode {
        let planeGeometry = createPlaneGeometry(for: anchor)
        let material = createMaterial(with: color)
        planeGeometry.materials = [material]
        
        let planeNode = SCNNode(geometry: planeGeometry)
        planeNode.simdPosition = anchor.center
        planeNode.eulerAngles.x = -Float.pi / 2
        
        let borderNode = createBorderNode(for: planeGeometry, color: color.withAlphaComponent(0.8))
        planeNode.addChildNode(borderNode)
        
        return planeNode
    }
    
    private static func createPlaneGeometry(for anchor: ARPlaneAnchor) -> SCNPlane {
        if #available(iOS 16.0, *) {
            return SCNPlane(width: CGFloat(anchor.planeExtent.width),
                            height: CGFloat(anchor.planeExtent.height))
        } else {
            return SCNPlane(width: CGFloat(anchor.extent.x),
                            height: CGFloat(anchor.extent.z))
        }
    }
    
    private static func createMaterial(with color: UIColor) -> SCNMaterial {
        let material = SCNMaterial()
        material.diffuse.contents = color
        material.isDoubleSided = true
        material.lightingModel = .constant
        material.writesToDepthBuffer = true
        material.readsFromDepthBuffer = true
        return material
    }
    
    private static func createBorderNode(for geometry: SCNPlane, color: UIColor) -> SCNNode {
        let borderGeometry = SCNPlane(width: geometry.width + 0.01,
                                      height: geometry.height + 0.01)
        
        let material = SCNMaterial()
        material.diffuse.contents = color
        material.isDoubleSided = true
        material.lightingModel = .constant
        
        borderGeometry.materials = [material]
        
        let borderNode = SCNNode(geometry: borderGeometry)
        borderNode.position.z = 0.001
        
        return borderNode
    }
}

================
File: Features/WallDetection/Views/ARView/Rendering/PlaneNodeUpdater.swift
================
import SceneKit
import ARKit

class PlaneNodeUpdater {
    static func updatePlaneNode(_ node: SCNNode, with anchor: ARPlaneAnchor) {
        node.simdPosition = anchor.center
        
        if let geometry = node.geometry as? SCNPlane {
            let newWidth: CGFloat
            let newHeight: CGFloat
            
            if #available(iOS 16.0, *) {
                newWidth = CGFloat(anchor.planeExtent.width)
                newHeight = CGFloat(anchor.planeExtent.height)
            } else {
                newWidth = CGFloat(anchor.extent.x)
                newHeight = CGFloat(anchor.extent.z)
            }
            
            geometry.width = newWidth
            geometry.height = newHeight
            
            if let borderNode = node.childNodes.first,
               let borderGeometry = borderNode.geometry as? SCNPlane {
                borderGeometry.width = newWidth + 0.01
                borderGeometry.height = newHeight + 0.01
            }
        }
    }
}

================
File: Features/WallDetection/Views/ARView/WallManagement/WallColorManager.swift
================
import UIKit

actor WallColorManager {
    private var colorMap: [UUID: UIColor] = [:]
    private var nextColorIndex = 0
    
    private let colors: [UIColor] = [
        UIColor(red: 0.0, green: 0.8, blue: 0.0, alpha: 0.5),
        UIColor(red: 0.0, green: 0.4, blue: 1.0, alpha: 0.5),
        UIColor(red: 1.0, green: 0.5, blue: 0.0, alpha: 0.5),
        UIColor(red: 0.7, green: 0.0, blue: 1.0, alpha: 0.5),
        UIColor(red: 1.0, green: 0.0, blue: 0.5, alpha: 0.5),
        UIColor(red: 1.0, green: 0.8, blue: 0.0, alpha: 0.5),
        UIColor(red: 0.0, green: 0.7, blue: 0.7, alpha: 0.5),
        UIColor(red: 1.0, green: 0.0, blue: 0.0, alpha: 0.5),
        UIColor(red: 0.5, green: 0.8, blue: 0.0, alpha: 0.5),
        UIColor(red: 0.0, green: 0.5, blue: 0.5, alpha: 0.5)
    ]
    
    func getColor(for groupID: UUID) async -> UIColor {
        return colorMap[groupID] ?? UIColor.gray
    }
    
    func assignColor(for groupID: UUID) async {
        colorMap[groupID] = colors[nextColorIndex % colors.count]
        nextColorIndex += 1
    }
    
    func releaseColor(for groupID: UUID) async {
        colorMap.removeValue(forKey: groupID)
    }
}

================
File: Features/WallDetection/Views/ARView/WallManagement/WallGroupCache.swift
================
import ARKit
import Foundation

actor WallGroupCache {
    private let cache: BaseCache<[ARPlaneAnchor]>
    private let cleanupThreshold: TimeInterval = 60  // 1分以上アクセスのないグループを削除
    
    init(maxGroups: Int = 20, cleanupInterval: TimeInterval = 30) {
        self.cache = BaseCache<[ARPlaneAnchor]>(
            maxItems: maxGroups,
            cleanupInterval: cleanupInterval
        )
    }
    
    func initialize() async throws {
        try await cache.initialize()
    }
    
    func store(groupID: UUID, anchors: [ARPlaneAnchor]) async throws {
        try await cache.store(anchors, forKey: groupID)
    }
    
    func getAnchors(for groupID: UUID) async -> [ARPlaneAnchor]? {
        try? await cache.get(forKey: groupID)
    }
    
    func getAllGroups() async -> [(UUID, [ARPlaneAnchor])] {
        let keys = await cache.keys
        var groups: [(UUID, [ARPlaneAnchor])] = []
        
        for key in keys {
            if let anchors = await getAnchors(for: key) {
                groups.append((key, anchors))
            }
        }
        
        return groups
    }
    
    func remove(groupID: UUID) async {
        try? await cache.remove(forKey: groupID)
    }
}

================
File: Features/WallDetection/Views/ARView/WallManagement/WallGroupManager.swift
================
import ARKit

actor WallGroupManager {
    private let cache: WallGroupCache
    private let colorManager: WallColorManager
    private var isInitialized = false
    
    init() {
        self.cache = WallGroupCache()
        self.colorManager = WallColorManager()
    }
    
    func initialize() async throws {
        if isInitialized { return }
        try await cache.initialize()
        isInitialized = true
    }
    
    func addWall(_ wall: ARPlaneAnchor) async throws -> UUID {
        if !isInitialized {
            try await initialize()
        }
        
        guard wall.alignment == .vertical else {
            throw AppError.ar(.wallGroupError("垂直な壁面のみ追加できます"))
        }
        
        // 既存グループとの互換性チェック
        let groups = await cache.getAllGroups()
        for (groupID, anchors) in groups {
            if await isWallCompatible(wall, with: anchors) {
                var updatedAnchors = anchors
                updatedAnchors.append(wall)
                try await cache.store(groupID: groupID, anchors: updatedAnchors)
                return groupID
            }
        }
        
        // 新しいグループの作成
        let newGroupID = UUID()
        try await cache.store(groupID: newGroupID, anchors: [wall])
        await colorManager.assignColor(for: newGroupID)
        return newGroupID
    }
    
    func removeWall(_ wall: ARPlaneAnchor) async {
        let groups = await cache.getAllGroups()
        for (groupID, anchors) in groups {
            if anchors.contains(where: { $0.identifier == wall.identifier }) {
                let updatedAnchors = anchors.filter { $0.identifier != wall.identifier }
                if updatedAnchors.isEmpty {
                    await cache.remove(groupID: groupID)
                    await colorManager.releaseColor(for: groupID)
                } else {
                    try? await cache.store(groupID: groupID, anchors: updatedAnchors)
                }
                return
            }
        }
    }
    
    func getColor(for groupID: UUID) async -> UIColor {
        await colorManager.getColor(for: groupID)
    }
    
    func isWallCompatible(_ wall: ARPlaneAnchor, with groupWalls: [ARPlaneAnchor]) async -> Bool {
        guard wall.alignment == .vertical else { return false }
        
        let wallData = wall.planeNormalAndPosition
        for groupWall in groupWalls {
            let groupWallData = groupWall.planeNormalAndPosition
            let normalDifference = wallData.normal.distance(to: groupWallData.normal)
            let positionDifference = wallData.position.distance(to: groupWallData.position)
            
            if normalDifference < 0.1 && positionDifference < 0.5 {
                return true
            }
        }
        return false
    }
    
    func isInSameGroup(_ wall1: ARPlaneAnchor, as wall2: ARPlaneAnchor) async -> Bool {
        let groups = await cache.getAllGroups()
        return groups.contains { _, anchors in
            anchors.contains { $0.identifier == wall1.identifier } &&
            anchors.contains { $0.identifier == wall2.identifier }
        }
    }
    
    func reset() async {
        let groups = await cache.getAllGroups()
        for (groupID, _) in groups {
            await cache.remove(groupID: groupID)
            await colorManager.releaseColor(for: groupID)
        }
    }
}

================
File: Features/WallDetection/Views/ARView/ARMainContentView.swift
================
import SwiftUI
import ARKit

struct ARMainContentView: View {
    @ObservedObject var viewModel: MeasurementViewModel
    @ObservedObject var wallTargetingVM: WallTargetingViewModel
    let arServices: ARServices
    
    var body: some View {
        ZStack {
            ARViewContainer(
                viewModel: viewModel,
                wallTargetingVM: wallTargetingVM,
                arServices: arServices
            )
            
            ReticuleMark(state: reticuleState)
                .position(x: UIScreen.main.bounds.width / 2,
                          y: UIScreen.main.bounds.height / 2)
            
            VStack(spacing: 0) {
                errorMessageBanner
                
                Spacer()
                
                if let distance = wallTargetingVM.currentDistance {
                    distanceText(distance)
                }
                
                Spacer()
                
                actionButton
                    .padding(.bottom, 34)
            }
        }
        .edgesIgnoringSafeArea(.all)
        .onAppear(perform: startMeasurement)
        .onDisappear(perform: stopMeasurement)
    }
    
    private var errorMessageBanner: some View {
        Group {
            if let errorMessage = viewModel.errorMessage {
                Text(errorMessage)
                    .foregroundColor(.white)
                    .font(.callout)
                    .multilineTextAlignment(.center)
                    .padding()
                    .background(Color.red.opacity(0.8))
                    .cornerRadius(8)
                    .padding()
                    .transition(.move(edge: .top).combined(with: .opacity))
                    .zIndex(1)
                    .padding(.top, 60)
            }
        }
        .animation(.easeInOut, value: viewModel.errorMessage)
    }
    
    private func distanceText(_ distance: Float) -> some View {
        Text(String(format: "%.1f cm", distance * 100))
            .font(.title2)
            .padding()
            .background(Color.black.opacity(0.7))
            .foregroundColor(.white)
            .cornerRadius(8)
    }
    
    private var actionButton: some View {
        Button(action: {
            Task {
                switch wallTargetingVM.targetingState {
                case .targeting:
                    await wallTargetingVM.lockWall()
                case .locked:
                    wallTargetingVM.unlockWall()
                default:
                    break
                }
            }
        }) {
            Text(wallTargetingVM.targetingState == .locked ? "固定を解除" : "壁面を固定")
                .padding()
                .background(buttonBackgroundColor)
                .foregroundColor(.white)
                .cornerRadius(8)
        }
        .disabled(!isButtonEnabled)
        .opacity(isButtonEnabled ? 1.0 : 0.5)
        .padding()
    }
    
    private var buttonBackgroundColor: Color {
        switch wallTargetingVM.targetingState {
        case .locked: return .blue
        case .targeting: return .blue
        case .searching: return .gray
        }
    }
    
    private var isButtonEnabled: Bool {
        wallTargetingVM.targetingState == .locked || wallTargetingVM.targetingState == .targeting
    }
    
    private var reticuleState: ReticuleMark.State {
        switch wallTargetingVM.targetingState {
        case .searching: return .normal
        case .targeting: return .targeting
        case .locked: return .normal
        }
    }
    
    private func startMeasurement() {
        viewModel.startMeasurement()
    }
    
    private func stopMeasurement() {
        viewModel.stopMeasurement()
    }
}

================
File: Features/WallDetection/Views/ARView/ARViewContainer.swift
================
import SwiftUI
import ARKit
import SceneKit

class ARViewHolder {
    weak var view: ARSCNView?
}

struct ARViewContainer: UIViewRepresentable {
    let viewModel: MeasurementViewModel
    let wallTargetingVM: WallTargetingViewModel
    let arServices: ARServices
    
    final class Coordinator: NSObject {
        var parent: ARViewContainer
        var sceneCoordinator: ARSceneCoordinator?
        
        init(_ parent: ARViewContainer) {
            self.parent = parent
        }
    }
    
    func makeUIView(context: Context) -> ARSCNView {
        let arView = ARSCNView()
        let sceneCoordinator = ARSceneCoordinator(self, wallTargetingVM: wallTargetingVM)
        context.coordinator.sceneCoordinator = sceneCoordinator
        sceneCoordinator.arViewHolder.view = arView
        
        if let provider = arServices as? ARServicesProvider {
            provider.setCoordinator(sceneCoordinator)
        }
        
        arServices.setupAR(arView)
        wallTargetingVM.setCoordinator(sceneCoordinator)
        
        arView.session.delegate = sceneCoordinator
        arView.delegate = sceneCoordinator
        
        return arView
    }
    
    func updateUIView(_ uiView: ARSCNView, context: Context) {}
    
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
}

================
File: Features/WallDetection/Views/Components/ReticuleMark.swift
================
// ReticuleMark.swift

import SwiftUI

// MARK: - Models

extension ReticuleMark {
    enum State {
        case normal
        case targeting
        case hidden
        
        var strokeColor: Color {
            switch self {
            case .normal:
                return .black
            case .targeting:
                return .green
            case .hidden:
                return .clear
            }
        }
    }
}

// MARK: - View

struct ReticuleMark: View {
    private enum Constants {
        static let size: CGFloat = 8
        static let strokeWidth: CGFloat = 2
        static let backgroundOpacity: Double = 0.5
    }
    
    let state: State
    
    var body: some View {
        Circle()
            .strokeBorder(state.strokeColor, lineWidth: Constants.strokeWidth)
            .frame(width: Constants.size, height: Constants.size)
            .background(
                Circle()
                    .fill(Color.white.opacity(Constants.backgroundOpacity))
                    .frame(width: Constants.size, height: Constants.size)
            )
            .opacity(state == .hidden ? 0 : 1)
    }
}

================
File: Features/WallDetection/Views/Components/WallDetectionOverlay.swift
================
import SwiftUI
import ARKit


struct WallDetectionOverlay: View {
    @ObservedObject var viewModel: MeasurementViewModel
    let onWallSelected: (ARPlaneAnchor) -> Void
    
    var body: some View {
        ZStack {
            if viewModel.detectedWalls.isEmpty {
                EmptyWallView()
            } else {
                WallMarkersView(walls: viewModel.detectedWalls, onWallSelected: onWallSelected)
            }
        }
    }
}

private struct EmptyWallView: View {
    var body: some View {
        Text("壁面を探しています...")
            .foregroundColor(.white)
            .padding()
            .background(Color.black.opacity(0.5))
            .cornerRadius(8)
    }
}

private struct WallMarkersView: View {
    let walls: [ARPlaneAnchor]
    let onWallSelected: (ARPlaneAnchor) -> Void
    
    var body: some View {
        ForEach(walls, id: \.identifier) { wall in
            WallIndicator(
                wall: wall,
                onTap: {
                    onWallSelected(wall)
                }
            )
            .position(
                x: CGFloat(wall.transform.columns.3.x * 500 + 200),
                y: CGFloat(wall.transform.columns.3.y * 500 + 400)
            )
        }
    }
}

================
File: Features/WallDetection/Views/Components/WallIndicator.swift
================
import SwiftUI
import ARKit

struct WallIndicator: View {
    let wall: ARPlaneAnchor
    let onTap: () -> Void
    
    private enum Constants {
        static let iconSize: CGFloat = 40
        static let backgroundOpacity: Double = 0.5
        static let cornerRadius: CGFloat = 4
        static let padding: CGFloat = 4
    }
    
    var body: some View {
        VStack(spacing: Constants.padding) {
            indicatorIcon
            indicatorLabel
        }
        .onTapGesture(perform: onTap)
    }
    
    private var indicatorIcon: some View {
        Image(systemName: "square.dashed")
            .font(.system(size: Constants.iconSize))
            .foregroundColor(.green)
    }
    
    private var indicatorLabel: some View {
        Text("タップして固定")
            .font(.caption)
            .foregroundColor(.white)
            .padding(Constants.padding)
            .background(Color.black.opacity(Constants.backgroundOpacity))
            .cornerRadius(Constants.cornerRadius)
    }
}

================
File: Features/WallDetection/Views/MainView.swift
================
import SwiftUI
import ARKit

struct MainView: View {
    var body: some View {
        ARContentContainer()
    }
}

private struct ARContentContainer: View {
    @State private var viewModel: MeasurementViewModel?
    @State private var wallTargetingVM = WallTargetingViewModel()
    @State private var arServices: ARServices?
    
    var body: some View {
        ZStack {
            if let viewModel = viewModel, let arServices = arServices {
                ARMainContentView(
                    viewModel: viewModel,
                    wallTargetingVM: wallTargetingVM,
                    arServices: arServices
                )
            }
        }
        .task {
            let performanceMonitor = await DevicePerformanceMonitor.create()
            let configService = ARConfigurationServiceImpl(performanceMonitor: performanceMonitor)
            self.arServices = await ARServicesProvider(configurationService: configService)
            
            guard let arServices = self.arServices else { return }
            
            self.viewModel = MeasurementViewModel(
                distanceViewModel: DistanceViewModel(),
                wallDetectionViewModel: WallDetectionViewModel(
                    wallDetectionService: WallDetectionService(arSession: ARSession())
                ),
                arServices: arServices
            )
        }
    }
}

================
File: Resources/Localization/ja.lproj/Localizable.strings
================
/* AR Tracking */
"ar.tracking.normal" = "トラッキングは正常です";
"ar.tracking.excessive_motion" = "動きが速すぎます";
"ar.tracking.insufficient_features" = "特徴点が不足しています";
"ar.tracking.initializing" = "初期化中...";
"ar.tracking.relocalizing" = "環境を再認識中...";
"ar.tracking.limited" = "トラッキングが制限されています";
"ar.tracking.not_available" = "トラッキングできません";

/* AR Session */
"ar.session.failed" = "ARセッションエラー";
"ar.not_available" = "AR機能を利用できません";
"ar.initialization" = "初期化中";
"ar.relocalizing" = "再認識中";
"ar.insufficient_features" = "特徴点が不足しています";
"ar.excessive_motion" = "動きが速すぎます";
"ar.cache.error" = "キャッシュエラー: %@";
"ar.wall.error" = "壁面エラー: %@";

/* AR Recovery */
"ar.recovery.slow_down" = "デバイスの動きを遅くしてください";
"ar.recovery.more_features" = "明るい場所で使用してください";
"ar.recovery.wait" = "しばらくお待ちください";
"ar.recovery.general" = "別の場所で試してください";
"ar.recovery.restart" = "アプリを再起動してください";
"ar.recovery.restart_session" = "ARセッションを再起動してください";
"ar.recovery.check_device" = "デバイスがARに対応しているか確認してください";
"ar.recovery.scan_area" = "周囲の環境を再スキャンしてください";
"ar.recovery.more_light" = "より明るい場所で試してください";
"ar.recovery.restart_app" = "アプリを再起動して再度試してください";
"ar.recovery.rescan_wall" = "壁面を再スキャンしてください";

/* Sensor */
"sensor.init.failed" = "センサーの初期化に失敗しました";
"sensor.calibration.required" = "センサーのキャリブレーションが必要です";
"sensor.system.overload" = "システムの負荷が高すぎます";
"sensor.consecutive.errors" = "連続してエラーが発生しています";
"sensor.resource.unavailable" = "センサーリソースを利用できません";
"sensor.measurement.error" = "測定エラー: %@";
"sensor.data.invalid" = "センサーデータが無効です";

/* Sensor Recovery */
"sensor.recovery.restart" = "アプリを再起動してください";
"sensor.recovery.calibrate" = "センサーのキャリブレーションを実行してください";
"sensor.recovery.close_apps" = "他のアプリを終了してください";
"sensor.recovery.reset" = "センサーをリセットしてください";
"sensor.recovery.check_usage" = "他のアプリのセンサー使用を確認してください";
"sensor.recovery.retry" = "もう一度試してください";

/* System */
"system.memory.warning" = "メモリが不足しています";
"system.task.cancelled" = "タスクがキャンセルされました";
"system.resource.limit" = "リソース制限: %@";
"system.unexpected.state" = "予期しない状態: %@";

/* System Recovery */
"system.recovery.free_memory" = "他のアプリを終了してメモリを解放してください";
"system.recovery.retry" = "もう一度試してください";
"system.recovery.free_resources" = "使用していないリソースを解放してください";
"system.recovery.restart" = "アプリを再起動してください";
