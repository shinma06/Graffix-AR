File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
Graffix-AR/
  App/
    Graffix-ARApp.swift
    Info.plist
  Assets/
    Assets.xcassets/
      AccentColor.colorset/
        Contents.json
      AppIcon.appiconset/
        Contents.json
      Contents.json
    Preview Content/
      Preview Assets.xcassets/
        Contents.json
  Common/
    Errors/
      AppError.swift
      ErrorHandling.swift
    Extensions/
      SIMD4+Extensions.swift
      UIView+Extensions.swift
    Protocols/
      ErrorHandlingViewModel.swift
    ViewModels/
      BaseViewModel.swift
  Features/
    Common/
      Models/
        ARConfigurationOptions.swift
      Protocols/
        ARConfigurationService.swift
      Services/
        ARConfigurationProvider.swift
        ARConfigurationServiceImpl.swift
        ARConfigurationSettings.swift
        ARServices.swift
        ARServicesProvider.swift
        DevicePerformanceMonitor.swift
      ViewModels/
        ARViewModel.swift
    DistanceMeasurement/
      Models/
        DistanceData.swift
        SensorType.swift
      Services/
        SensorManager.swift
      ViewModels/
        DistanceViewModel.swift
        MeasurementViewModel.swift
    WallDetection/
      Models/
        WallDetectionEvent.swift
        WallDetectionMode.swift
      Services/
        WallDetectionService.swift
        WallDistanceTracker.swift
      ViewModels/
        WallDetectionViewModel.swift
        WallTargetingViewModel.swift
      Views/
        ARView/
          Coordinators/
            ARSceneCoordinator.swift
          Rendering/
            PlaneNodeCache.swift
            PlaneNodeFactory.swift
            PlaneNodeUpdater.swift
          WallManagement/
            WallColorManager.swift
            WallGroupCache.swift
            WallGroupManager.swift
          ARContentView.swift
          ARViewContainer.swift
        Components/
          ReticuleMark.swift
          WallDetectionOverlay.swift
          WallIndicator.swift
        ContentView.swift
  Resources/
    Localization/
      ja.lproj/
        Localizable.strings
Graffix-AR.xcodeproj/
  project.xcworkspace/
    contents.xcworkspacedata
  xcshareddata/
    xcschemes/
      Mock Up.xcscheme
  xcuserdata/
    shinma.xcuserdatad/
      xcschemes/
        xcschememanagement.plist
  project.pbxproj
.gitignore

================================================================
Files
================================================================

================
File: Graffix-AR/App/Graffix-ARApp.swift
================
import SwiftUI

@main
struct ARtestApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
    }
}

================
File: Graffix-AR/App/Info.plist
================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>CFBundleIdentifier</key>
    <string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
    
    <key>NSCameraUsageDescription</key>
    <string>ARでの壁面検出と距離測定のためにカメラを使用します。</string>
    
    <key>CFBundleName</key>
    <string>$(PRODUCT_NAME)</string>
    
    <key>UISupportedInterfaceOrientations</key>
    <array>
        <string>UIInterfaceOrientationPortrait</string>
    </array>
    
    <key>MinimumOSVersion</key>
    <string>18.1</string>
    
    <key>LSRequiresIPhoneOS</key>
    <true/>
</dict>
</plist>

================
File: Graffix-AR/Assets/Assets.xcassets/AccentColor.colorset/Contents.json
================
{
  "colors" : [
    {
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

================
File: Graffix-AR/Assets/Assets.xcassets/AppIcon.appiconset/Contents.json
================
{
  "images" : [
    {
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    },
    {
      "appearances" : [
        {
          "appearance" : "luminosity",
          "value" : "dark"
        }
      ],
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    },
    {
      "appearances" : [
        {
          "appearance" : "luminosity",
          "value" : "tinted"
        }
      ],
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

================
File: Graffix-AR/Assets/Assets.xcassets/Contents.json
================
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

================
File: Graffix-AR/Assets/Preview Content/Preview Assets.xcassets/Contents.json
================
{
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}

================
File: Graffix-AR/Common/Errors/AppError.swift
================
import ARKit
import Foundation

enum AppError: LocalizedError {
    case ar(ARError)
    case sensor(SensorError)
    case system(SystemError)
    
    // MARK: - Nested Error Types
    
    enum ARError {
        case trackingStateChanged(ARCamera.TrackingState)
        case sessionFailed(Error)
        case notAvailable
        case initialization
        case relocalizing
        case insufficientFeatures
        case excessiveMotion
        case cacheError(String)
        case wallGroupError(String)
    }
    
    enum SensorError {
        case initializationFailed
        case calibrationRequired
        case systemOverload
        case consecutiveErrors
        case resourceUnavailable
        case measurementError(String)
        case dataInvalid
    }
    
    enum SystemError {
        case memoryWarning
        case taskCancelled
        case resourceLimit(String)
        case unexpectedState(String)
    }
}

// MARK: - Error Descriptions
extension AppError {
    var errorDescription: String? {
        switch self {
        case .ar(let error):
            return error.localizedDescription
        case .sensor(let error):
            return error.localizedDescription
        case .system(let error):
            return error.localizedDescription
        }
    }
    
    var recoverySuggestion: String? {
        switch self {
        case .ar(let error):
            return error.recoverySuggestion
        case .sensor(let error):
            return error.recoverySuggestion
        case .system(let error):
            return error.recoverySuggestion
        }
    }
}

// MARK: - AR Error Descriptions
extension AppError.ARError {
    var localizedDescription: String {
        switch self {
        case .trackingStateChanged(let state):
            switch state {
            case .normal:
                return String(localized: "ar.tracking.normal")
            case .limited(let reason):
                switch reason {
                case .excessiveMotion:
                    return String(localized: "ar.tracking.excessive_motion")
                case .insufficientFeatures:
                    return String(localized: "ar.tracking.insufficient_features")
                case .initializing:
                    return String(localized: "ar.tracking.initializing")
                case .relocalizing:
                    return String(localized: "ar.tracking.relocalizing")
                @unknown default:
                    return String(localized: "ar.tracking.limited")
                }
            case .notAvailable:
                return String(localized: "ar.tracking.not_available")
            }
        case .sessionFailed(let error):
            return String(localized: "ar.session.failed") + ": \(error.localizedDescription)"
        case .notAvailable:
            return String(localized: "ar.not_available")
        case .initialization:
            return String(localized: "ar.initialization")
        case .relocalizing:
            return String(localized: "ar.relocalizing")
        case .insufficientFeatures:
            return String(localized: "ar.insufficient_features")
        case .excessiveMotion:
            return String(localized: "ar.excessive_motion")
        case .cacheError(let message):
            return String(format: String(localized: "ar.cache.error"), message)
        case .wallGroupError(let message):
            return String(format: String(localized: "ar.wall.error"), message)
        }
    }
    
    var recoverySuggestion: String {
        switch self {
        case .trackingStateChanged(let state):
            switch state {
            case .limited(let reason):
                switch reason {
                case .excessiveMotion:
                    return String(localized: "ar.recovery.slow_down")
                case .insufficientFeatures:
                    return String(localized: "ar.recovery.more_features")
                case .initializing, .relocalizing:
                    return String(localized: "ar.recovery.wait")
                @unknown default:
                    return String(localized: "ar.recovery.general")
                }
            case .notAvailable:
                return String(localized: "ar.recovery.restart")
            case .normal:
                return ""
            }
        case .sessionFailed:
            return String(localized: "ar.recovery.restart_session")
        case .notAvailable:
            return String(localized: "ar.recovery.check_device")
        case .initialization:
            return String(localized: "ar.recovery.wait")
        case .relocalizing:
            return String(localized: "ar.recovery.scan_area")
        case .insufficientFeatures:
            return String(localized: "ar.recovery.more_light")
        case .excessiveMotion:
            return String(localized: "ar.recovery.slow_down")
        case .cacheError:
            return String(localized: "ar.recovery.restart_app")
        case .wallGroupError:
            return String(localized: "ar.recovery.rescan_wall")
        }
    }
}

// MARK: - Sensor Error Descriptions
extension AppError.SensorError {
    var localizedDescription: String {
        switch self {
        case .initializationFailed:
            return String(localized: "sensor.init.failed")
        case .calibrationRequired:
            return String(localized: "sensor.calibration.required")
        case .systemOverload:
            return String(localized: "sensor.system.overload")
        case .consecutiveErrors:
            return String(localized: "sensor.consecutive.errors")
        case .resourceUnavailable:
            return String(localized: "sensor.resource.unavailable")
        case .measurementError(let message):
            return String(format: String(localized: "sensor.measurement.error"), message)
        case .dataInvalid:
            return String(localized: "sensor.data.invalid")
        }
    }
    
    var recoverySuggestion: String {
        switch self {
        case .initializationFailed:
            return String(localized: "sensor.recovery.restart")
        case .calibrationRequired:
            return String(localized: "sensor.recovery.calibrate")
        case .systemOverload:
            return String(localized: "sensor.recovery.close_apps")
        case .consecutiveErrors:
            return String(localized: "sensor.recovery.reset")
        case .resourceUnavailable:
            return String(localized: "sensor.recovery.check_usage")
        case .measurementError:
            return String(localized: "sensor.recovery.retry")
        case .dataInvalid:
            return String(localized: "sensor.recovery.retry")
        }
    }
}

// MARK: - System Error Descriptions
extension AppError.SystemError {
    var localizedDescription: String {
        switch self {
        case .memoryWarning:
            return String(localized: "system.memory.warning")
        case .taskCancelled:
            return String(localized: "system.task.cancelled")
        case .resourceLimit(let message):
            return String(format: String(localized: "system.resource.limit"), message)
        case .unexpectedState(let message):
            return String(format: String(localized: "system.unexpected.state"), message)
        }
    }
    
    var recoverySuggestion: String {
        switch self {
        case .memoryWarning:
            return String(localized: "system.recovery.free_memory")
        case .taskCancelled:
            return String(localized: "system.recovery.retry")
        case .resourceLimit:
            return String(localized: "system.recovery.free_resources")
        case .unexpectedState:
            return String(localized: "system.recovery.restart")
        }
    }
}

================
File: Graffix-AR/Common/Errors/ErrorHandling.swift
================
import Foundation
import UIKit

protocol ErrorHandling: AnyObject {
    func handle(_ error: AppError)
    func recover(from error: AppError) async throws
    func showError(_ error: AppError)
    func logError(_ error: AppError)
}

final class AppErrorHandler: ErrorHandling {
    static let shared = AppErrorHandler()
    private var errorLogger: ErrorLogging
    private var errorPresenter: ErrorPresenting
    
    init(
        errorLogger: ErrorLogging = DefaultErrorLogger(),
        errorPresenter: ErrorPresenting = DefaultErrorPresenter()
    ) {
        self.errorLogger = errorLogger
        self.errorPresenter = errorPresenter
    }
    
    func handle(_ error: AppError) {
        logError(error)
        showError(error)
        
        // エラー種別に応じた特別な処理
        switch error {
        case .ar(.trackingStateChanged(let state)) where state == .normal:
            errorPresenter.dismissError()
        case .system(.memoryWarning):
            NotificationCenter.default.post(
                name: UIApplication.didReceiveMemoryWarningNotification,
                object: nil
            )
        default:
            break
        }
    }
    
    func recover(from error: AppError) async throws {
        switch error {
        case .ar(.trackingStateChanged):
            try await resetARSession()
        case .sensor(.calibrationRequired):
            try await calibrateSensors()
        case .system(.memoryWarning):
            try await cleanupMemory()
        default:
            // デフォルトの回復処理
            try await defaultRecovery(for: error)
        }
    }
    
    func showError(_ error: AppError) {
        errorPresenter.present(error)
    }
    
    func logError(_ error: AppError) {
        errorLogger.log(error)
    }
    
    // MARK: - Private Methods
    
    private func resetARSession() async throws {
        // ARSessionのリセット処理
    }
    
    private func calibrateSensors() async throws {
        // センサーキャリブレーション
    }
    
    private func cleanupMemory() async throws {
        // メモリクリーンアップ
    }
    
    private func defaultRecovery(for error: AppError) async throws {
        // デフォルトの回復処理
    }
}

// MARK: - Error Logging

protocol ErrorLogging {
    func log(_ error: AppError)
}

struct DefaultErrorLogger: ErrorLogging {
    func log(_ error: AppError) {
        // 実際のログ実装
        print("Error: \(error.localizedDescription)")
        if let recovery = error.recoverySuggestion {
            print("Recovery suggestion: \(recovery)")
        }
    }
}

// MARK: - Error Presenting

protocol ErrorPresenting {
    func present(_ error: AppError)
    func dismissError()
}

struct DefaultErrorPresenter: ErrorPresenting {
    func present(_ error: AppError) {
        // UI上でのエラー表示
        // 例：アラート表示など
    }
    
    func dismissError() {
        // エラー表示の消去
    }
}

================
File: Graffix-AR/Common/Extensions/SIMD4+Extensions.swift
================
import ARKit

extension SIMD4 {
    var xyz: SIMD3<Scalar> {
        SIMD3(x, y, z)
    }
}

extension SIMD3 where Scalar == Float {
    func distance(to other: SIMD3<Float>) -> Float {
        let difference = self - other
        return sqrt(difference.x * difference.x +
                    difference.y * difference.y +
                    difference.z * difference.z)
    }
}

extension ARPlaneAnchor {
    var normal: simd_float3 {
        // 垂直な壁面の場合、法線ベクトルを計算
        // transformのcolumns.2が平面の向きを示す
        transform.columns.2.xyz
    }
    
    var planeNormalAndPosition: (normal: simd_float3, position: simd_float3) {
        (normal: transform.columns.2.xyz,
         position: transform.columns.3.xyz)
    }
}

================
File: Graffix-AR/Common/Extensions/UIView+Extensions.swift
================
import UIKit

extension UIView {
    func findView<T: UIView>(of type: T.Type) -> T? {
        if let view = self as? T {
            return view
        }
        for subview in subviews {
            if let found = subview.findView(of: type) {
                return found
            }
        }
        return nil
    }
}

================
File: Graffix-AR/Common/Protocols/ErrorHandlingViewModel.swift
================
import SwiftUI
import Combine

/// エラーハンドリング機能を提供するViewModelプロトコル
protocol ErrorHandlingViewModel: ObservableObject {
    /// 現在のエラーメッセージ
    var errorMessage: String? { get set }
    
    /// エラーハンドリングサービス
    var errorHandler: ErrorHandling { get }
    
    /// エラーを処理する
    func handleError(_ error: AppError)
}

extension ErrorHandlingViewModel {
    func handleError(_ error: AppError) {
        Task { @MainActor in
            errorHandler.handle(error)
            errorMessage = error.localizedDescription
            if let recovery = error.recoverySuggestion {
                errorMessage = (errorMessage ?? "") + "\n" + recovery
            }
        }
    }
}

================
File: Graffix-AR/Common/ViewModels/BaseViewModel.swift
================
import SwiftUI
import Combine

class BaseViewModel: ObservableObject, ErrorHandlingViewModel {
    @Published var errorMessage: String?
    let errorHandler: ErrorHandling
    
    init(errorHandler: ErrorHandling = AppErrorHandler.shared) {
        self.errorHandler = errorHandler
    }
}

================
File: Graffix-AR/Features/Common/Models/ARConfigurationOptions.swift
================
import ARKit

struct ARConfigurationOptions {
    let preferredFPS: Int
    let useAntialiasing: Bool
    let frameSemantics: ARWorldTrackingConfiguration.FrameSemantics
    let showDebugOptions: Bool
    let usePersonSegmentation: Bool
    
    static func defaultOptions() -> ARConfigurationOptions {
        ARConfigurationOptions(
            preferredFPS: 60,
            useAntialiasing: true,
            frameSemantics: [.smoothedSceneDepth, .sceneDepth],
            showDebugOptions: false,
            usePersonSegmentation: true
        )
    }
    
    static func lowPerformanceOptions() -> ARConfigurationOptions {
        ARConfigurationOptions(
            preferredFPS: 30,
            useAntialiasing: false,
            frameSemantics: [],
            showDebugOptions: false,
            usePersonSegmentation: false
        )
    }
}

================
File: Graffix-AR/Features/Common/Protocols/ARConfigurationService.swift
================
import ARKit
import SceneKit

@MainActor  // プロトコルレベルでMainActorを指定
protocol ARConfigurationService {
    /// ARセッションの設定を作成する
    func createConfiguration() -> ARWorldTrackingConfiguration
    
    /// セッション実行時のオプションを取得する
    func getDefaultRunOptions() -> ARSession.RunOptions
    
    /// ARSCNViewの設定を行う
    func configureView(_ view: ARSCNView)
    
    /// 設定の更新を行う
    func updateConfiguration(_ configuration: ARWorldTrackingConfiguration)
}

================
File: Graffix-AR/Features/Common/Services/ARConfigurationProvider.swift
================
import ARKit
import SceneKit

@MainActor
struct ARConfigurationProvider {
    // MARK: - Properties
    private let performanceMonitor: DevicePerformanceMonitor
    
    // MARK: - Initialization
    init(performanceMonitor: DevicePerformanceMonitor) {
        self.performanceMonitor = performanceMonitor
    }
    
    // MARK: - Public Methods
    func createConfiguration() -> ARWorldTrackingConfiguration {
        let configuration = ARWorldTrackingConfiguration()
        let options = ConfigurationOptions.createFor(performanceMonitor.currentLevel)
        
        // 基本設定
        configuration.planeDetection = ARConfigurationSettings.Session.planeDetection
        configuration.environmentTexturing = ARConfigurationSettings.Session.environmentTexturing
        configuration.frameSemantics = options.frameSemantics
        
        // iOS 14以降の機能設定を分離
        if ARConfigurationSettings.FeatureAvailability.advancedFeaturesAvailable {
            configuration.isAutoFocusEnabled = true
        }
        
        if options.usePersonSegmentation {
            configuration.frameSemantics.insert(.personSegmentationWithDepth)
        }
        
        return configuration
    }
    
    func getDefaultRunOptions() -> ARSession.RunOptions {
        performanceMonitor.currentLevel == .high
        ? ARConfigurationSettings.Session.fullResetOptions
        : ARConfigurationSettings.Session.defaultResetOptions
    }
    
    func configureView(_ view: ARSCNView) {
        let options = ConfigurationOptions.createFor(performanceMonitor.currentLevel)
        
        view.preferredFramesPerSecond = options.preferredFPS
        configureRendering(view, options: options)
        view.automaticallyUpdatesLighting = true
    }
    
    
    
    // MARK: - Private Types
    private struct ConfigurationOptions {
        let preferredFPS: Int
        let useAntialiasing: Bool
        let frameSemantics: ARWorldTrackingConfiguration.FrameSemantics
        let showDebugOptions: Bool
        let usePersonSegmentation: Bool
        
        static func createFor(_ level: DevicePerformanceMonitor.PerformanceLevel) -> ConfigurationOptions {
            let frameRates = ARConfigurationSettings.Performance.defaultFrameRates
            
            let fps: Int
            let frameSemantics: ARWorldTrackingConfiguration.FrameSemantics
            
            switch level {
            case .high:
                fps = frameRates.high
                frameSemantics = ARConfigurationSettings.Session.FrameSemantics.high
            case .medium:
                fps = frameRates.medium
                frameSemantics = ARConfigurationSettings.Session.FrameSemantics.medium
            case .low:
                fps = frameRates.low
                frameSemantics = ARConfigurationSettings.Session.FrameSemantics.low
            }
            
            let deviceSettings = ARConfigurationSettings.Device.getDeviceSpecificSettings()
            
            return ConfigurationOptions(
                preferredFPS: fps,
                useAntialiasing: level == .high && deviceSettings.preferHighPerformance,
                frameSemantics: frameSemantics,
                showDebugOptions: false,
                usePersonSegmentation: level != .low
            )
        }
    }
    
    // MARK: - Private Methods
    private func configureRendering(_ view: ARSCNView, options: ConfigurationOptions) {
        guard MTLCreateSystemDefaultDevice() != nil else { return }
        
        view.antialiasingMode = options.useAntialiasing
        ? ARConfigurationSettings.Rendering.antialiasing.high
        : ARConfigurationSettings.Rendering.antialiasing.none
        
#if DEBUG
        configureDebug(view, showDebugOptions: options.showDebugOptions)
#endif
    }
    
#if DEBUG
    private func configureDebug(_ view: ARSCNView, showDebugOptions: Bool) {
        view.showsStatistics = showDebugOptions
        view.debugOptions = showDebugOptions ? ARConfigurationSettings.Rendering.debugOptions : []
    }
    
    static func monitorPerformance(_ session: ARSession) {
        guard let frame = session.currentFrame else { return }
        
        let metrics: [String: Any] = [
            "Frame Timestamp": frame.timestamp,
            "Tracking State": String(describing: frame.camera.trackingState),
            "Camera Transform": frame.camera.transform,
            "Anchor Count": frame.anchors.count
        ]
        
        print("AR Performance Metrics:", metrics)
        
        if frame.anchors.count > ARConfigurationSettings.Performance.monitoring.anchorCountWarningThreshold {
            print("Warning: High anchor count (\(frame.anchors.count))")
        }
        
        if case .limited(let reason) = frame.camera.trackingState {
            print("Limited Tracking Reason: \(reason)")
        }
    }
#endif
}

================
File: Graffix-AR/Features/Common/Services/ARConfigurationServiceImpl.swift
================
import ARKit
import SceneKit

@MainActor
final class ARConfigurationServiceImpl: ARConfigurationService {
    private let performanceMonitor: DevicePerformanceMonitor
    
    init(performanceMonitor: DevicePerformanceMonitor) {
        self.performanceMonitor = performanceMonitor
    }
    
    func createConfiguration() -> ARWorldTrackingConfiguration {
        let configuration = ARWorldTrackingConfiguration()
        let options = createOptionsForCurrentPerformance()
        
        // 基本設定
        configuration.planeDetection = ARConfigurationSettings.Session.planeDetection
        configuration.environmentTexturing = ARConfigurationSettings.Session.environmentTexturing
        configuration.frameSemantics = options.frameSemantics
        
        // iOS 14以降の機能設定
        if ARConfigurationSettings.FeatureAvailability.advancedFeaturesAvailable {
            configuration.isAutoFocusEnabled = true
        }
        
        if options.usePersonSegmentation {
            configuration.frameSemantics.insert(.personSegmentationWithDepth)
        }
        
        return configuration
    }
    
    func getDefaultRunOptions() -> ARSession.RunOptions {
        performanceMonitor.currentLevel == .high
        ? ARConfigurationSettings.Session.fullResetOptions
        : ARConfigurationSettings.Session.defaultResetOptions
    }
    
    func configureView(_ view: ARSCNView) {
        let options = createOptionsForCurrentPerformance()
        
        view.preferredFramesPerSecond = options.preferredFPS
        configureRendering(view, options: options)
        view.automaticallyUpdatesLighting = true
    }
    
    func updateConfiguration(_ configuration: ARWorldTrackingConfiguration) {
        let options = createOptionsForCurrentPerformance()
        configuration.frameSemantics = options.frameSemantics
        
        if options.usePersonSegmentation {
            configuration.frameSemantics.insert(.personSegmentationWithDepth)
        }
    }
    
    // MARK: - Private Methods
    
    private func createOptionsForCurrentPerformance() -> ARConfigurationOptions {
        let deviceSettings = ARConfigurationSettings.Device.getDeviceSpecificSettings()
        
        switch performanceMonitor.currentLevel {
        case .high:
            return ARConfigurationOptions(
                preferredFPS: ARConfigurationSettings.Performance.defaultFrameRates.high,
                useAntialiasing: deviceSettings.preferHighPerformance,
                frameSemantics: ARConfigurationSettings.Session.FrameSemantics.high,
                showDebugOptions: false,
                usePersonSegmentation: true
            )
            
        case .medium:
            return ARConfigurationOptions(
                preferredFPS: ARConfigurationSettings.Performance.defaultFrameRates.medium,
                useAntialiasing: false,
                frameSemantics: ARConfigurationSettings.Session.FrameSemantics.medium,
                showDebugOptions: false,
                usePersonSegmentation: true
            )
            
        case .low:
            return ARConfigurationOptions(
                preferredFPS: ARConfigurationSettings.Performance.defaultFrameRates.low,
                useAntialiasing: false,
                frameSemantics: ARConfigurationSettings.Session.FrameSemantics.low,
                showDebugOptions: false,
                usePersonSegmentation: false
            )
        }
    }
    
    private func configureRendering(_ view: ARSCNView, options: ARConfigurationOptions) {
        guard MTLCreateSystemDefaultDevice() != nil else { return }
        
        view.antialiasingMode = options.useAntialiasing
        ? ARConfigurationSettings.Rendering.antialiasing.high
        : ARConfigurationSettings.Rendering.antialiasing.none
        
#if DEBUG
        configureDebug(view, showDebugOptions: options.showDebugOptions)
#endif
    }
    
#if DEBUG
    private func configureDebug(_ view: ARSCNView, showDebugOptions: Bool) {
        view.showsStatistics = showDebugOptions
        view.debugOptions = showDebugOptions ? ARConfigurationSettings.Rendering.debugOptions : []
    }
    
    private func monitorPerformance(_ session: ARSession) {
        guard let frame = session.currentFrame else { return }
        
        let metrics: [String: Any] = [
            "Frame Timestamp": frame.timestamp,
            "Tracking State": String(describing: frame.camera.trackingState),
            "Camera Transform": frame.camera.transform,
            "Anchor Count": frame.anchors.count
        ]
        
        print("AR Performance Metrics:", metrics)
        
        if frame.anchors.count > ARConfigurationSettings.Performance.monitoring.anchorCountWarningThreshold {
            print("Warning: High anchor count (\(frame.anchors.count))")
        }
        
        if case .limited(let reason) = frame.camera.trackingState {
            print("Limited Tracking Reason: \(reason)")
        }
    }
#endif
}

================
File: Graffix-AR/Features/Common/Services/ARConfigurationSettings.swift
================
import ARKit
import SceneKit

/// AR機能の設定値を集約する名前空間
enum ARConfigurationSettings {
    /// セッション関連の設定
    enum Session {
        /// 平面検出の設定
        static let planeDetection: ARWorldTrackingConfiguration.PlaneDetection = [.vertical]
        
        /// 環境テクスチャの設定
        static let environmentTexturing: ARWorldTrackingConfiguration.EnvironmentTexturing = .automatic
        
        /// フレームセマンティクスの設定
        enum FrameSemantics {
            static let high: ARWorldTrackingConfiguration.FrameSemantics = [.smoothedSceneDepth, .sceneDepth]
            static let medium: ARWorldTrackingConfiguration.FrameSemantics = [.smoothedSceneDepth]
            static let low: ARWorldTrackingConfiguration.FrameSemantics = []
        }
        
        /// セッションのリセットオプション
        static let defaultResetOptions: ARSession.RunOptions = [.resetTracking, .removeExistingAnchors]
        static let fullResetOptions: ARSession.RunOptions = [
            .resetTracking,
            .removeExistingAnchors,
            .resetSceneReconstruction
        ]
    }
    
    /// パフォーマンス関連の設定
    enum Performance {
        /// フレームレートの設定
        static let defaultFrameRates = FrameRates(
            high: 60,
            medium: 45,
            low: 30
        )
        
        /// プロセッサ数の閾値
        static let processorThresholds = ProcessorThresholds(
            high: 6,  // 6コア以上
            medium: 4 // 4-5コア
        )
        
        /// メモリ容量の閾値（GB単位）
        static let memoryThresholds = MemoryThresholds(
            minimum: 2.0,  // 2GB未満はlow
            standard: 4.0  // 4GB未満はmedium
        )
        
        /// パフォーマンスモニタリングの設定
        static let monitoring = MonitoringSettings(
            anchorCountWarningThreshold: 30,
            updateInterval: 1.0,
            thermalStateRecoveryDelay: 5.0
        )
    }
    
    /// レンダリング関連の設定
    enum Rendering {
        /// アンチエイリアシングの設定
        static let antialiasing = AntialiasingSettings(
            none: SCNAntialiasingMode.none,
            high: SCNAntialiasingMode.multisampling4X
        )
        
        /// デバッグ表示のオプション
        static let debugOptions: SCNDebugOptions = [.showFeaturePoints, .showWorldOrigin]
    }
    
    /// デバイス依存の設定
    enum Device {
        /// デバイスの種類による調整
        static func getDeviceSpecificSettings() -> DeviceSpecificSettings {
            let idiom = UIDevice.current.userInterfaceIdiom
            switch idiom {
            case .pad:
                return DeviceSpecificSettings(
                    maxAnchors: 50,
                    preferHighPerformance: true
                )
            default:
                return DeviceSpecificSettings(
                    maxAnchors: 30,
                    preferHighPerformance: false
                )
            }
        }
    }
    
    /// 機能の利用可否
    enum FeatureAvailability {
        /// iOS 14以降で利用可能な機能が使用可能かどうか
        static var advancedFeaturesAvailable: Bool {
            if #available(iOS 14.0, *) {
                return true
            }
            return false
        }
    }
}

// MARK: - Supporting Types

extension ARConfigurationSettings {
    struct FrameRates {
        let high: Int
        let medium: Int
        let low: Int
    }
    
    struct ProcessorThresholds {
        let high: Int
        let medium: Int
    }
    
    struct MemoryThresholds {
        let minimum: Double
        let standard: Double
    }
    
    struct MonitoringSettings {
        let anchorCountWarningThreshold: Int
        let updateInterval: TimeInterval
        let thermalStateRecoveryDelay: TimeInterval
    }
    
    struct AntialiasingSettings {
        let none: SCNAntialiasingMode
        let high: SCNAntialiasingMode
    }
    
    struct DeviceSpecificSettings {
        let maxAnchors: Int
        let preferHighPerformance: Bool
    }
}

================
File: Graffix-AR/Features/Common/Services/ARServices.swift
================
import ARKit

@MainActor
protocol ARServices: AnyObject {
    var configurationService: ARConfigurationService { get }
    func setupAR(_ view: ARSCNView)
    func lockWall(_ wall: ARPlaneAnchor) async
    func unlockWall() async
}

================
File: Graffix-AR/Features/Common/Services/ARServicesProvider.swift
================
import ARKit

@MainActor
class ARServicesProvider: ARServices {
    let configurationService: ARConfigurationService
    private let arSession: ARSession
    private var coordinator: ARSceneCoordinator?
    
    init(arSession: ARSession = ARSession(),
         configurationService: ARConfigurationService? = nil) {
        self.arSession = arSession
        self.configurationService = configurationService ?? ARConfigurationServiceImpl(
            performanceMonitor: DevicePerformanceMonitor()
        )
    }
    
    func setupAR(_ view: ARSCNView) {
        let configuration = configurationService.createConfiguration()
        let options = configurationService.getDefaultRunOptions()
        
        view.session.run(configuration, options: options)
        configurationService.configureView(view)
    }
    
    func setCoordinator(_ coordinator: ARSceneCoordinator) {
        self.coordinator = coordinator
    }
    
    func lockWall(_ wall: ARPlaneAnchor) async {
        await coordinator?.lockWall(with: wall.identifier)
    }
    
    func unlockWall() async {
        await coordinator?.unlockWall()
    }
}

================
File: Graffix-AR/Features/Common/Services/DevicePerformanceMonitor.swift
================
import Foundation
import UIKit
import Combine

@MainActor
final class DevicePerformanceMonitor: ObservableObject {
    // MARK: - Public Properties
    @Published private(set) var currentLevel: PerformanceLevel
    @Published private(set) var systemLoadLevel: SystemLoad
    
    // MARK: - Private Properties
    private var memoryWarningSubscription: AnyCancellable?
    private var thermalStateSubscription: AnyCancellable?
    private var updateTimer: Timer?
    private var recoveryTask: Task<Void, Never>?
    private let updateInterval: TimeInterval
    
    // MARK: - Initialization
    init() {
        self.currentLevel = .medium
        self.systemLoadLevel = .normal
        self.updateInterval = ARConfigurationSettings.Performance.monitoring.updateInterval
        
        setupObservers()
        startMonitoring()
    }
    
    // MARK: - Public Methods
    func startMonitoring() {
        updateTimer?.invalidate()
        updateTimer = Timer.scheduledTimer(
            withTimeInterval: updateInterval,
            repeats: true
        ) { [weak self] _ in
            Task { @MainActor [weak self] in
                await self?.updatePerformanceMetrics()
            }
        }
    }
    
    func stopMonitoring() {
        cleanup()
    }
    
    // MARK: - Private Methods
    private func cleanup() {
        updateTimer?.invalidate()
        updateTimer = nil
        recoveryTask?.cancel()
        recoveryTask = nil
        memoryWarningSubscription?.cancel()
        thermalStateSubscription?.cancel()
        memoryWarningSubscription = nil
        thermalStateSubscription = nil
    }
    
    private func setupObservers() {
        memoryWarningSubscription = NotificationCenter.default.publisher(
            for: UIApplication.didReceiveMemoryWarningNotification
        )
        .receive(on: DispatchQueue.main)
        .sink { [weak self] _ in
            Task { @MainActor [weak self] in
                await self?.handleMemoryWarning()
            }
        }
        
        if #available(iOS 16.0, *) {
            let processInfo = ProcessInfo.processInfo
            thermalStateSubscription = NotificationCenter.default.publisher(
                for: ProcessInfo.thermalStateDidChangeNotification
            )
            .receive(on: DispatchQueue.main)
            .sink { [weak self] _ in
                Task { @MainActor [weak self] in
                    self?.handleThermalStateChange(processInfo.thermalState)
                }
            }
        }
    }
    
    private func updatePerformanceMetrics() async {
        let baseLevel = evaluateHardwareCapabilities()
        let adjustedLevel = adjustForSystemConditions(baseLevel)
        
        if currentLevel != adjustedLevel {
            currentLevel = adjustedLevel
        }
    }
    
    private func evaluateHardwareCapabilities() -> PerformanceLevel {
        let processorCount = ProcessInfo.processInfo.processorCount
        let totalMemory = ProcessInfo.processInfo.physicalMemory
        let thresholds = ARConfigurationSettings.Performance.processorThresholds
        let memoryThresholds = ARConfigurationSettings.Performance.memoryThresholds
        
        // プロセッサ数による基本評価
        let baseLevel: PerformanceLevel
        switch processorCount {
        case thresholds.high...: baseLevel = .high
        case thresholds.medium...: baseLevel = .medium
        default: baseLevel = .low
        }
        
        // メモリ容量による調整
        let memoryGB = Double(totalMemory) / 1_000_000_000
        if memoryGB < memoryThresholds.minimum && baseLevel != .low {
            return .low
        } else if memoryGB < memoryThresholds.standard && baseLevel == .high {
            return .medium
        }
        
        // デバイス特性による調整
        let deviceSettings = ARConfigurationSettings.Device.getDeviceSpecificSettings()
        return deviceSettings.preferHighPerformance ? baseLevel : min(baseLevel, .medium)
    }
    
    private func adjustForSystemConditions(_ baseLevel: PerformanceLevel) -> PerformanceLevel {
        switch systemLoadLevel {
        case .high:
            return baseLevel == .high ? .medium : .low
        case .critical:
            return .low
        case .normal:
            return baseLevel
        }
    }
    
    private func handleMemoryWarning() async {
        systemLoadLevel = .high
        
        recoveryTask?.cancel()
        recoveryTask = Task { [weak self] in
            try? await Task.sleep(
                nanoseconds: UInt64(ARConfigurationSettings.Performance.monitoring.thermalStateRecoveryDelay * 1_000_000_000)
            )
            guard let self = self, !Task.isCancelled else { return }
            self.resetSystemLoad()
        }
    }
    
    private func resetSystemLoad() {
        if systemLoadLevel == .high {
            systemLoadLevel = .normal
        }
    }
    
    @available(iOS 16.0, *)
    private func handleThermalStateChange(_ state: ProcessInfo.ThermalState) {
        switch state {
        case .nominal:
            systemLoadLevel = .normal
        case .fair, .serious:
            systemLoadLevel = .high
        case .critical:
            systemLoadLevel = .critical
        @unknown default:
            systemLoadLevel = .normal
        }
    }
}

// MARK: - Supporting Types
extension DevicePerformanceMonitor {
    enum PerformanceLevel: Int, Comparable {
        case low = 0
        case medium = 1
        case high = 2
        
        static func < (lhs: PerformanceLevel, rhs: PerformanceLevel) -> Bool {
            lhs.rawValue < rhs.rawValue
        }
    }
    
    enum SystemLoad {
        case normal
        case high
        case critical
    }
}

================
File: Graffix-AR/Features/Common/ViewModels/ARViewModel.swift
================
import ARKit
import SwiftUI

class ARViewModel: BaseViewModel {
    @Published var trackingState: ARCamera.TrackingState?
    let arSession: ARSession
    
    init(arSession: ARSession = ARSession(),
         errorHandler: ErrorHandling = AppErrorHandler.shared) {
        self.arSession = arSession
        super.init(errorHandler: errorHandler)
    }
    
    func resetSession() {
        let configuration = ARWorldTrackingConfiguration()
        configuration.planeDetection = [.vertical]
        arSession.run(configuration, options: [.resetTracking, .removeExistingAnchors])
    }
}

================
File: Graffix-AR/Features/DistanceMeasurement/Models/DistanceData.swift
================
import Foundation

struct DistanceData {
    let distance: Float
    let isReliable: Bool
    let sensorType: SensorType
    let timestamp: Date
}

================
File: Graffix-AR/Features/DistanceMeasurement/Models/SensorType.swift
================
enum SensorType {
    case lidar
    case tof
    case ultrasonic
    
    var reliableRange: ClosedRange<Float> {
        switch self {
        case .lidar: return 0.5...5.0 // 50cm-5m
        case .tof: return 0.03...0.5  // 3cm-50cm
        case .ultrasonic: return 0.01...0.03 // 1cm-3cm
        }
    }
}

================
File: Graffix-AR/Features/DistanceMeasurement/Services/SensorManager.swift
================
import Foundation
import ARKit

protocol SensorManagerDelegate: AnyObject {
    func sensorManager(_ manager: SensorManager, didUpdateDistance distance: Float, sensorType: SensorType)
    func sensorManager(_ manager: SensorManager, didFailWithError error: Error)
}

class SensorManager {
    weak var delegate: SensorManagerDelegate?
    private var measurementTask: Task<Void, Never>?
    private var streamContinuation: AsyncStream<DistanceData>.Continuation?
    private var isRunning: Bool = false
    
    private let updateInterval: TimeInterval = 1.0 / 30.0
    private let batchSize = 5
    private var measurementBuffer: [DistanceData] = []
    private let bufferCapacity = 30
    
    private var dynamicUpdateInterval: TimeInterval
    private let minUpdateInterval: TimeInterval = 1.0 / 60.0
    private let maxUpdateInterval: TimeInterval = 1.0 / 15.0
    private var systemLoadLevel: Int = 0
    private let maxSystemLoadLevel = 5
    
    private var consecutiveErrorCount: Int = 0
    private let maxConsecutiveErrors = 3
    private var lastSuccessfulMeasurement: Date?
    private var isCalibrating = false
    
    init() {
        self.dynamicUpdateInterval = updateInterval
        setupMemoryWarningObserver()
    }
    
    func distanceStream() -> AsyncStream<DistanceData> {
        AsyncStream<DistanceData> { continuation in
            self.streamContinuation = continuation
            continuation.onTermination = { [weak self] _ in
                self?.stopMeasuring()
            }
        }
    }
    
    func startMeasuring() {
        guard !isRunning else { return }
        guard canStartMeasurement() else {
            handleError(AppError.sensor(.resourceUnavailable))
            return
        }
        
        isRunning = true
        consecutiveErrorCount = 0
        measurementBuffer.reserveCapacity(bufferCapacity)
        
        measurementTask = Task { [weak self] in
            guard let self = self else { return }
            
            do {
                try await self.initializeSensor()
                
                while !Task.isCancelled && self.isRunning {
                    if await self.shouldPerformCalibration() && !self.isCalibrating {
                        self.isCalibrating = true
                        try await self.performCalibration()
                        self.isCalibrating = false
                    }
                    
                    try await self.processMeasurements()
                    try await self.adjustedSleep()
                }
            } catch {
                if let appError = error as? AppError {
                    self.handleError(appError)
                } else {
                    self.handleError(AppError.sensor(.measurementError(error.localizedDescription)))
                }
            }
            
            self.streamContinuation?.finish()
        }
    }
    
    func stopMeasuring() {
        isRunning = false
        measurementTask?.cancel()
        measurementTask = nil
        streamContinuation?.finish()
        streamContinuation = nil
        measurementBuffer.removeAll(keepingCapacity: true)
    }
    
    private func processMeasurements() async throws {
        for _ in 0..<batchSize {
            if Task.isCancelled || !isRunning { break }
            
            let measurement = try await performSingleMeasurement()
            measurementBuffer.append(measurement)
            
            if measurementBuffer.count >= bufferCapacity {
                await flushMeasurements()
            }
        }
        
        if !measurementBuffer.isEmpty {
            await flushMeasurements()
        }
    }
    
    private func performSingleMeasurement() async throws -> DistanceData {
        if systemLoadLevel >= maxSystemLoadLevel {
            throw AppError.sensor(.systemOverload)
        }
        
        let dummyDistance = Float.random(in: 0.5...5.0)
        
        let distanceData = DistanceData(
            distance: dummyDistance,
            isReliable: true,
            sensorType: .lidar,
            timestamp: Date()
        )
        
        lastSuccessfulMeasurement = Date()
        consecutiveErrorCount = 0
        return distanceData
    }
    
    private func flushMeasurements() async {
        guard !measurementBuffer.isEmpty else { return }
        
        let latestMeasurement = measurementBuffer.last!
        delegate?.sensorManager(self,
                                didUpdateDistance: latestMeasurement.distance,
                                sensorType: latestMeasurement.sensorType)
        
        for measurement in measurementBuffer {
            streamContinuation?.yield(measurement)
        }
        
        measurementBuffer.removeAll(keepingCapacity: true)
    }
    
    private func adjustedSleep() async throws {
        let interval = min(max(dynamicUpdateInterval * Double(systemLoadLevel + 1),
                               minUpdateInterval),
                           maxUpdateInterval)
        try await Task.sleep(nanoseconds: UInt64(interval * 1_000_000_000))
    }
    
    private func setupMemoryWarningObserver() {
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(handleMemoryWarning),
            name: UIApplication.didReceiveMemoryWarningNotification,
            object: nil
        )
    }
    
    @objc private func handleMemoryWarning() {
        systemLoadLevel = maxSystemLoadLevel
        measurementBuffer.removeAll(keepingCapacity: true)
    }
    
    private func initializeSensor() async throws {
        if arc4random_uniform(100) < 5 {
            throw AppError.sensor(.initializationFailed)
        }
    }
    
    private func shouldPerformCalibration() async -> Bool {
        guard let lastMeasurement = lastSuccessfulMeasurement else { return true }
        return Date().timeIntervalSince(lastMeasurement) > 300
    }
    
    private func performCalibration() async throws {
        if arc4random_uniform(100) < 10 {
            throw AppError.sensor(.calibrationRequired)
        }
    }
    
    private func canStartMeasurement() -> Bool {
        return true
    }
    
    private func handleError(_ error: AppError) {
        delegate?.sensorManager(self, didFailWithError: error)
        
        switch error {
        case .sensor(let sensorError):
            switch sensorError {
            case .initializationFailed, .resourceUnavailable, .consecutiveErrors:
                stopMeasuring()
            case .systemOverload:
                if consecutiveErrorCount >= maxConsecutiveErrors {
                    stopMeasuring()
                }
            case .calibrationRequired, .measurementError, .dataInvalid:
                consecutiveErrorCount += 1
                if consecutiveErrorCount >= maxConsecutiveErrors {
                    stopMeasuring()
                }
            }
        default:
            break
        }
    }
    
    deinit {
        NotificationCenter.default.removeObserver(self)
        stopMeasuring()
    }
}

================
File: Graffix-AR/Features/DistanceMeasurement/ViewModels/DistanceViewModel.swift
================
import ARKit
import SwiftUI

final class DistanceViewModel: BaseViewModel {
    @Published private(set) var currentDistance: DistanceData?
    private let sensorManager: SensorManager
    private let arSession: ARSession
    
    init(sensorManager: SensorManager = SensorManager(),
         arSession: ARSession = ARSession(),
         errorHandler: ErrorHandling = AppErrorHandler.shared) {
        self.sensorManager = sensorManager
        self.arSession = arSession
        super.init(errorHandler: errorHandler)
        setupDelegates()
    }
    
    private func setupDelegates() {
        sensorManager.delegate = self
    }
    
    func startMeasurement() {
        sensorManager.startMeasuring()
        errorMessage = nil
    }
    
    func stopMeasurement() {
        sensorManager.stopMeasuring()
    }
    
    deinit {
        stopMeasurement()
    }
}

// MARK: - SensorManagerDelegate
extension DistanceViewModel: SensorManagerDelegate {
    nonisolated func sensorManager(_ manager: SensorManager, didUpdateDistance distance: Float, sensorType: SensorType) {
        let isReliable = sensorType.reliableRange.contains(distance)
        Task { @MainActor in
            self.currentDistance = DistanceData(
                distance: distance,
                isReliable: isReliable,
                sensorType: sensorType,
                timestamp: Date()
            )
        }
    }
    
    nonisolated func sensorManager(_ manager: SensorManager, didFailWithError error: Error) {
        Task { @MainActor in
            if let appError = error as? AppError {
                self.handleError(appError)
            } else {
                self.handleError(.system(.unexpectedState(error.localizedDescription)))
            }
        }
    }
}

================
File: Graffix-AR/Features/DistanceMeasurement/ViewModels/MeasurementViewModel.swift
================
import ARKit
import SwiftUI
import Combine

final class MeasurementViewModel: BaseViewModel {
    @Published private(set) var currentDistance: DistanceData?
    @Published var detectedWalls: [ARPlaneAnchor]
    
    let wallDetectionViewModel: WallDetectionViewModel
    private let distanceViewModel: DistanceViewModel
    private let arServices: ARServices
    private var cancellables = Set<AnyCancellable>()
    
    var trackingState: ARCamera.TrackingState? { wallDetectionViewModel.trackingState }
    var detectionMode: WallDetectionMode { wallDetectionViewModel.detectionMode }
    
    init(distanceViewModel: DistanceViewModel = DistanceViewModel(),
         wallDetectionViewModel: WallDetectionViewModel = WallDetectionViewModel(
            wallDetectionService: WallDetectionService(arSession: ARSession())),
         arServices: ARServices,
         errorHandler: ErrorHandling = AppErrorHandler.shared) {
        self.distanceViewModel = distanceViewModel
        self.wallDetectionViewModel = wallDetectionViewModel
        self.arServices = arServices
        self.detectedWalls = []
        super.init(errorHandler: errorHandler)
        
        setupErrorMessageBinding()
        setupDistanceBinding()
        setupWallsBinding()
    }
    
    private func setupErrorMessageBinding() {
        distanceViewModel.objectWillChange.sink { [weak self] in
            if let error = self?.distanceViewModel.errorMessage {
                self?.errorMessage = error
            }
        }.store(in: &cancellables)
        
        wallDetectionViewModel.objectWillChange.sink { [weak self] in
            if let error = self?.wallDetectionViewModel.errorMessage {
                self?.errorMessage = error
            }
        }.store(in: &cancellables)
    }
    
    private func setupDistanceBinding() {
        distanceViewModel.$currentDistance
            .assign(to: \.currentDistance, on: self)
            .store(in: &cancellables)
    }
    
    private func setupWallsBinding() {
        wallDetectionViewModel.$detectedWalls
            .assign(to: \.detectedWalls, on: self)
            .store(in: &cancellables)
    }
    
    func startMeasurement() {
        distanceViewModel.startMeasurement()
    }
    
    func stopMeasurement() {
        distanceViewModel.stopMeasurement()
    }
    
    func lockToWall(_ wall: ARPlaneAnchor) async {
        await arServices.lockWall(wall)
    }
    
    func unlockWall() async {
        await arServices.unlockWall()
    }
    
    deinit {
        cancellables.removeAll()
    }
}

================
File: Graffix-AR/Features/WallDetection/Models/WallDetectionEvent.swift
================
import ARKit

enum WallDetectionEvent {
    case wallsUpdated([ARPlaneAnchor])
    case wallLocked(ARPlaneAnchor)
    case wallUnlocked
    case trackingStateChanged(ARCamera.TrackingState)
    case sessionInterrupted
    case sessionResumes
    case error(AppError)
    
    var priority: EventPriority {
        switch self {
        case .error: return .high
        case .trackingStateChanged, .wallLocked, .wallUnlocked: return .medium
        case .wallsUpdated, .sessionInterrupted, .sessionResumes: return .low
        }
    }
}

enum EventPriority: Int, Comparable {
    case high = 0
    case medium = 1
    case low = 2
    
    static func < (lhs: EventPriority, rhs: EventPriority) -> Bool {
        lhs.rawValue < rhs.rawValue
    }
}

struct EventWrapper {
    let event: WallDetectionEvent
    let timestamp: Date
    
    var isExpired: Bool {
        Date().timeIntervalSince(timestamp) > 5.0
    }
}

================
File: Graffix-AR/Features/WallDetection/Models/WallDetectionMode.swift
================
enum WallDetectionMode {
    case free
    case locked
}

================
File: Graffix-AR/Features/WallDetection/Services/WallDetectionService.swift
================
import ARKit
import Foundation

protocol WallDetectionServiceDelegate: AnyObject {
    func wallDetectionService(_ service: WallDetectionService, didUpdateWalls walls: [ARPlaneAnchor]) async
    func wallDetectionService(_ service: WallDetectionService, didLockToWall wall: ARPlaneAnchor) async
    func wallDetectionServiceDidUnlock(_ service: WallDetectionService) async
    func wallDetectionService(_ service: WallDetectionService, didFailWithError error: AppError) async
}

@globalActor actor WallDetectionServiceActor {
    static let shared = WallDetectionServiceActor()
}

class WallDetectionService: NSObject, ARSessionDelegate {
    weak var delegate: WallDetectionServiceDelegate?
    private let arSession: ARSession
    private var currentWall: ARPlaneAnchor?
    private var isProcessingUpdate = false
    
    private var eventContinuation: AsyncStream<WallDetectionEvent>.Continuation?
    private var eventBuffer: [EventWrapper] = []
    private let maxBufferSize = 30
    private var eventProcessingTask: Task<Void, Never>?
    
    init(arSession: ARSession, delegate: WallDetectionServiceDelegate? = nil) {
        self.arSession = arSession
        self.delegate = delegate
        super.init()
        self.arSession.delegate = self
        setupEventProcessing()
    }
    
    func events() -> AsyncStream<WallDetectionEvent> {
        AsyncStream { continuation in
            self.eventContinuation = continuation
            continuation.onTermination = { [weak self] _ in
                self?.cleanupEventProcessing()
            }
        }
    }
    
    @WallDetectionServiceActor
    func detectWalls() async -> [ARPlaneAnchor] {
        guard let currentFrame = arSession.currentFrame else { return [] }
        
        let walls = currentFrame.anchors.compactMap { anchor -> ARPlaneAnchor? in
            guard let planeAnchor = anchor as? ARPlaneAnchor,
                  planeAnchor.alignment == .vertical else {
                return nil
            }
            return planeAnchor
        }
        
        queueEvent(.wallsUpdated(walls))
        return walls
    }
    
    @WallDetectionServiceActor
    func lockToWall(_ wall: ARPlaneAnchor) async {
        currentWall = wall
        queueEvent(.wallLocked(wall))
        await delegate?.wallDetectionService(self, didLockToWall: wall)
    }
    
    @WallDetectionServiceActor
    func unlockWall() async {
        currentWall = nil
        queueEvent(.wallUnlocked)
        await delegate?.wallDetectionServiceDidUnlock(self)
    }
    
    // MARK: - ARSessionDelegate
    
    func session(_ session: ARSession, didFailWithError error: Error) {
        Task { @WallDetectionServiceActor in
            await handleSessionError(error)
        }
    }
    
    func session(_ session: ARSession, cameraDidChangeTrackingState camera: ARCamera) {
        Task { @WallDetectionServiceActor in
            await handleTrackingStateChange(camera.trackingState)
        }
    }
    
    func session(_ session: ARSession, didUpdate frame: ARFrame) {
        Task { @WallDetectionServiceActor in
            await processFrame(frame)
        }
    }
    
    // MARK: - Private Methods
    
    private func setupEventProcessing() {
        eventProcessingTask = Task { [weak self] in
            while !Task.isCancelled {
                try? await Task.sleep(nanoseconds: UInt64(1.0 / 30.0 * 1_000_000_000))
                await self?.processEventBuffer()
            }
        }
    }
    
    @WallDetectionServiceActor
    private func processEventBuffer() async {
        eventBuffer.removeAll { $0.isExpired }
        
        if eventBuffer.count > maxBufferSize {
            eventBuffer.sort { $0.event.priority < $1.event.priority }
            eventBuffer = Array(eventBuffer.prefix(maxBufferSize))
        }
        
        for wrapper in eventBuffer {
            eventContinuation?.yield(wrapper.event)
        }
        eventBuffer.removeAll()
    }
    
    @WallDetectionServiceActor
    private func queueEvent(_ event: WallDetectionEvent) {
        let wrapper = EventWrapper(event: event, timestamp: Date())
        eventBuffer.append(wrapper)
    }
    
    private func cleanupEventProcessing() {
        eventProcessingTask?.cancel()
        eventProcessingTask = nil
        eventBuffer.removeAll()
    }
    
    @WallDetectionServiceActor
    private func handleSessionError(_ error: Error) async {
        let appError = AppError.ar(.sessionFailed(error))
        queueEvent(.error(appError))
        await delegate?.wallDetectionService(self, didFailWithError: appError)
    }
    
    @WallDetectionServiceActor
    private func handleTrackingStateChange(_ state: ARCamera.TrackingState) async {
        queueEvent(.trackingStateChanged(state))
        
        switch state {
        case .normal:
            break
        case .notAvailable:
            await delegate?.wallDetectionService(self, didFailWithError: .ar(.trackingStateChanged(state)))
        case .limited(let reason):
            await delegate?.wallDetectionService(self, didFailWithError: .ar(.trackingStateChanged(.limited(reason))))
        }
    }
    
    @WallDetectionServiceActor
    private func processFrame(_ frame: ARFrame) async {
        guard !isProcessingUpdate else { return }
        isProcessingUpdate = true
        defer { isProcessingUpdate = false }
        
        let walls = frame.anchors.compactMap { anchor -> ARPlaneAnchor? in
            guard let planeAnchor = anchor as? ARPlaneAnchor,
                  planeAnchor.alignment == .vertical else {
                return nil
            }
            return planeAnchor
        }
        
        queueEvent(.wallsUpdated(walls))
        await delegate?.wallDetectionService(self, didUpdateWalls: walls)
    }
    
    deinit {
        cleanupEventProcessing()
    }
}

================
File: Graffix-AR/Features/WallDetection/Services/WallDistanceTracker.swift
================


================
File: Graffix-AR/Features/WallDetection/ViewModels/WallDetectionViewModel.swift
================
import ARKit
import SwiftUI

final class WallDetectionViewModel: BaseViewModel {
    @Published var detectionMode: WallDetectionMode = .free
    @Published var detectedWalls: [ARPlaneAnchor] = []
    @Published var trackingState: ARCamera.TrackingState?
    
    private let wallDetectionService: WallDetectionService
    private var eventProcessingTask: Task<Void, Never>?
    private var wallUpdateDebouncer: Task<Void, Never>?
    private let wallUpdateInterval: TimeInterval = 0.1
    
    init(wallDetectionService: WallDetectionService,
         arSession: ARSession = ARSession(),
         errorHandler: ErrorHandling = AppErrorHandler.shared) {
        self.wallDetectionService = wallDetectionService
        super.init(errorHandler: errorHandler)
        setupDelegates()
        setupEventProcessing()
    }
    
    private func setupDelegates() {
        wallDetectionService.delegate = self
    }
    
    private func setupEventProcessing() {
        eventProcessingTask = Task { [weak self] in
            guard let self = self else { return }
            
            for await event in wallDetectionService.events() {
                if Task.isCancelled { break }
                await self.processWallDetectionEvent(event)
            }
        }
    }
    
    private func processWallDetectionEvent(_ event: WallDetectionEvent) async {
        switch event {
        case .wallsUpdated(let walls):
            wallUpdateDebouncer?.cancel()
            wallUpdateDebouncer = Task { [weak self] in
                try? await Task.sleep(nanoseconds: UInt64(self?.wallUpdateInterval ?? 0.1 * 1_000_000_000))
                await self?.handleWallsUpdate(walls)
            }
            
        case .wallLocked(let wall):
            detectionMode = .locked
            if let index = detectedWalls.firstIndex(where: { $0.identifier == wall.identifier }) {
                detectedWalls[index] = wall
            }
            
        case .wallUnlocked:
            detectionMode = .free
            
        case .trackingStateChanged(let state):
            trackingState = state
            handleTrackingStateChange(state)
            
        case .sessionInterrupted:
            errorMessage = "ARセッションが中断されました"
            
        case .sessionResumes:
            errorMessage = nil
            
        case .error(let error):
            handleError(error)
        }
    }
    
    private func handleWallsUpdate(_ walls: [ARPlaneAnchor]) async {
        guard detectionMode == .free else { return }
        
        var updatedWalls = detectedWalls
        for wall in walls {
            if let index = updatedWalls.firstIndex(where: { $0.identifier == wall.identifier }) {
                updatedWalls[index] = wall
            } else {
                updatedWalls.append(wall)
            }
        }
        
        updatedWalls.removeAll { wall in
            !walls.contains { $0.identifier == wall.identifier }
        }
        
        detectedWalls = updatedWalls
    }
    
    private func handleTrackingStateChange(_ state: ARCamera.TrackingState) {
        switch state {
        case .normal:
            errorMessage = nil
        case .limited(let reason):
            let error = AppError.ar(.trackingStateChanged(.limited(reason)))
            handleError(error)
        case .notAvailable:
            let error = AppError.ar(.trackingStateChanged(.notAvailable))
            handleError(error)
        }
    }
    
    deinit {
        eventProcessingTask?.cancel()
        wallUpdateDebouncer?.cancel()
    }
}

// MARK: - WallDetectionServiceDelegate
extension WallDetectionViewModel: WallDetectionServiceDelegate {
    nonisolated func wallDetectionService(_ service: WallDetectionService, didUpdateWalls walls: [ARPlaneAnchor]) async {
        await MainActor.run {
            if self.detectionMode == .free {
                self.detectedWalls = walls
            }
        }
    }
    
    nonisolated func wallDetectionService(_ service: WallDetectionService, didLockToWall wall: ARPlaneAnchor) async {
        await MainActor.run {
            self.detectionMode = .locked
        }
    }
    
    nonisolated func wallDetectionServiceDidUnlock(_ service: WallDetectionService) async {
        await MainActor.run {
            self.detectionMode = .free
        }
    }
    
    nonisolated func wallDetectionService(_ service: WallDetectionService, didFailWithError error: AppError) async {
        await MainActor.run {
            self.handleError(error)
        }
    }
}

================
File: Graffix-AR/Features/WallDetection/ViewModels/WallTargetingViewModel.swift
================
import SwiftUI
import ARKit
import Combine

@MainActor
class WallTargetingViewModel: ObservableObject {
    enum TargetingState {
        case searching
        case targeting
        case locked
    }
    
    @Published private(set) var targetingState: TargetingState = .searching
    @Published private(set) var currentDistance: Float?
    @Published var errorMessage: String?
    
    private var targetedWall: ARPlaneAnchor?
    private weak var arSceneCoordinator: ARSceneCoordinator?
    
    // 非固定時は距離を表示しない
    func updateTargetedWall(_ wall: ARPlaneAnchor, distance: Float) {
        if targetingState == .locked {
            // 固定モード時は距離を更新
            if let lockedWall = targetedWall,
               wall.identifier == lockedWall.identifier {
                currentDistance = distance
            }
        } else {
            targetedWall = wall
            targetingState = .targeting
            // 非固定時は距離を表示しない
            currentDistance = nil
        }
    }
    
    // 壁面固定処理
    func lockWall() async {
        guard let wall = targetedWall else { return }
        guard let coordinator = arSceneCoordinator else { return }
        
        // 固定状態に移行
        targetingState = .locked
        // ARSceneCoordinatorに固定を通知
        await coordinator.lockWall(with: wall.identifier)
        // 固定後の距離測定開始
        startDistanceMeasurement()
    }
    
    // 固定解除処理
    func unlockWall() {
        guard let coordinator = arSceneCoordinator else { return }
        
        targetingState = .searching
        targetedWall = nil
        currentDistance = nil
        
        Task {
            await coordinator.unlockWall()
        }
    }
    
    // 固定時の距離測定
    private func startDistanceMeasurement() {
        // 距離測定ロジックは今後実装
        // 現状は仮の実装として、updateTargetedWallで更新される距離を表示
        if targetingState == .locked {
            // currentDistanceの更新を許可
        }
    }
    
    func setCoordinator(_ coordinator: ARSceneCoordinator) {
        arSceneCoordinator = coordinator
    }
    
    func clearTarget() {
        if targetingState != .locked {
            targetedWall = nil
            currentDistance = nil
            targetingState = .searching
        }
    }
}

================
File: Graffix-AR/Features/WallDetection/Views/ARView/Coordinators/ARSceneCoordinator.swift
================
import ARKit
import SceneKit
import SwiftUI

class ARSceneCoordinator: NSObject, ARSCNViewDelegate, ARSessionDelegate {
    let arViewHolder = ARViewHolder()
    private let parent: ARViewContainer
    private let wallGroupManager: WallGroupManager
    private let planeNodeCache: PlaneNodeCache
    private var lockedWallID: UUID?
    private var renderTasks: [UUID: Task<Void, Never>] = [:]
    private var cleanupTask: Task<Void, Never>?
    private let wallTargetingVM: WallTargetingViewModel
    private var intersectionCheckTask: Task<Void, Never>?
    
    init(_ parent: ARViewContainer, wallTargetingVM: WallTargetingViewModel) {
        self.parent = parent
        self.wallGroupManager = WallGroupManager()
        self.planeNodeCache = PlaneNodeCache()
        self.wallTargetingVM = wallTargetingVM
        super.init()
        
        Task {
            do {
                try await planeNodeCache.initialize()
            } catch {
                await handleError(error)
            }
        }
        
        setupTasks()
        setupMemoryWarningObserver()
    }
    
    private func setupTasks() {
        setupCleanupTask()
        setupIntersectionCheck()
    }
    
    private func setupCleanupTask() {
        cleanupTask = Task { [weak self] in
            while !Task.isCancelled {
                guard let self = self else { break }
                do {
                    try await Task.sleep(nanoseconds: UInt64(30 * 1_000_000_000))
                    await self.performCleanup()
                } catch {
                    if !Task.isCancelled {
                        await self.handleError(error)
                    }
                }
            }
        }
    }
    
    private func setupIntersectionCheck() {
        intersectionCheckTask = Task { [weak self] in
            while !Task.isCancelled {
                guard let self = self else { break }
                await self.checkIntersection()
                try? await Task.sleep(nanoseconds: UInt64(1.0 / 30.0 * 1_000_000_000))
            }
        }
    }
    
    private func checkIntersection() async {
        guard let arView = arViewHolder.view else { return }
        
        let bounds = await arView.bounds
        let viewCenter = CGPoint(
            x: bounds.width / 2,
            y: bounds.height / 2
        )
        
        if let result = await performRaycast(from: viewCenter, in: arView),
           let anchor = result.anchor as? ARPlaneAnchor {
            let distance = simd_length(result.worldTransform.columns.3.xyz)
            await wallTargetingVM.updateTargetedWall(anchor, distance: distance)
        } else {
            await wallTargetingVM.clearTarget()
        }
    }
    
    private func performRaycast(from point: CGPoint, in view: ARSCNView) async -> ARRaycastResult? {
        await MainActor.run {
            guard let query = view.raycastQuery(
                from: point,
                allowing: .existingPlaneGeometry,
                alignment: .vertical
            ) else { return nil }
            
            return view.session.raycast(query).first
        }
    }
    
    func renderer(_ renderer: SCNSceneRenderer, didAdd node: SCNNode, for anchor: ARAnchor) {
        guard let planeAnchor = anchor as? ARPlaneAnchor else { return }
        
        let taskID = planeAnchor.identifier
        renderTasks[taskID]?.cancel()
        renderTasks[taskID] = Task { [weak self] in
            guard let self = self else { return }
            do {
                if let lockedID = self.lockedWallID {
                    let detectedWalls = await MainActor.run { self.parent.viewModel.detectedWalls }
                    if let lockedWall = detectedWalls.first(where: { $0.identifier == lockedID }) {
                        let isInSameGroup = await self.wallGroupManager.isInSameGroup(planeAnchor, as: lockedWall)
                        if isInSameGroup {
                            let groupID = try await self.wallGroupManager.addWall(planeAnchor)
                            let color = await self.wallGroupManager.getColor(for: groupID)
                            let planeNode = PlaneNodeFactory.createPlaneNode(for: planeAnchor, color: color)
                            
                            await MainActor.run {
                                node.addChildNode(planeNode)
                            }
                            
                            try await self.planeNodeCache.store(identifier: planeAnchor.identifier, node: planeNode)
                        }
                    }
                } else {
                    let groupID = try await self.wallGroupManager.addWall(planeAnchor)
                    await updateDetectedWalls { walls in
                        walls.append(planeAnchor)
                    }
                    
                    let color = await self.wallGroupManager.getColor(for: groupID)
                    let planeNode = PlaneNodeFactory.createPlaneNode(for: planeAnchor, color: color)
                    
                    await MainActor.run {
                        node.addChildNode(planeNode)
                    }
                    
                    try await self.planeNodeCache.store(identifier: planeAnchor.identifier, node: planeNode)
                }
            } catch {
                if !Task.isCancelled {
                    await self.handleError(error)
                }
            }
        }
    }
    
    func renderer(_ renderer: SCNSceneRenderer, didUpdate node: SCNNode, for anchor: ARAnchor) {
        guard let planeAnchor = anchor as? ARPlaneAnchor else { return }
        
        let taskID = planeAnchor.identifier
        renderTasks[taskID]?.cancel()
        renderTasks[taskID] = Task { [weak self] in
            guard let self = self else { return }
            do {
                if let lockedID = self.lockedWallID {
                    let detectedWalls = await MainActor.run { self.parent.viewModel.detectedWalls }
                    if let lockedWall = detectedWalls.first(where: { $0.identifier == lockedID }) {
                        let isInSameGroup = await self.wallGroupManager.isInSameGroup(planeAnchor, as: lockedWall)
                        if isInSameGroup {
                            let groupID = try await self.wallGroupManager.addWall(planeAnchor)
                            let color = await self.wallGroupManager.getColor(for: groupID)
                            
                            let planeNode = try await self.planeNodeCache.getNode(for: planeAnchor.identifier)
                            await MainActor.run {
                                PlaneNodeUpdater.updatePlaneNode(planeNode, with: planeAnchor)
                                planeNode.geometry?.firstMaterial?.diffuse.contents = color
                            }
                        }
                    }
                } else {
                    let groupID = try await self.wallGroupManager.addWall(planeAnchor)
                    let color = await self.wallGroupManager.getColor(for: groupID)
                    
                    let planeNode = try await self.planeNodeCache.getNode(for: planeAnchor.identifier)
                    await MainActor.run {
                        PlaneNodeUpdater.updatePlaneNode(planeNode, with: planeAnchor)
                        planeNode.geometry?.firstMaterial?.diffuse.contents = color
                    }
                    
                    await updateDetectedWalls { walls in
                        if let index = walls.firstIndex(where: { $0.identifier == planeAnchor.identifier }) {
                            walls[index] = planeAnchor
                        }
                    }
                }
            } catch {
                if !Task.isCancelled {
                    await self.handleError(error)
                }
            }
        }
    }
    
    func renderer(_ renderer: SCNSceneRenderer, didRemove node: SCNNode, for anchor: ARAnchor) {
        guard let planeAnchor = anchor as? ARPlaneAnchor else { return }
        
        let taskID = planeAnchor.identifier
        renderTasks[taskID]?.cancel()
        renderTasks[taskID] = Task { [weak self] in
            guard let self = self else { return }
            do {
                if let lockedID = self.lockedWallID, planeAnchor.identifier == lockedID {
                    return
                }
                
                await updateDetectedWalls { walls in
                    walls.removeAll { $0.identifier == planeAnchor.identifier }
                }
                
                try await self.planeNodeCache.remove(identifier: planeAnchor.identifier)
                await self.wallGroupManager.removeWall(planeAnchor)
            } catch {
                if !Task.isCancelled {
                    await self.handleError(error)
                }
            }
        }
    }
    
    private func handleError(_ error: Error) async {
        await MainActor.run {
            if let appError = error as? AppError {
                parent.viewModel.handleError(appError)
            } else {
                parent.viewModel.handleError(.system(.unexpectedState(error.localizedDescription)))
            }
        }
    }
    
    private func updateDetectedWalls(_ update: (inout [ARPlaneAnchor]) -> Void) async {
        await MainActor.run {
            var walls = parent.viewModel.detectedWalls
            update(&walls)
            parent.viewModel.detectedWalls = walls
        }
    }
    
    private func setupMemoryWarningObserver() {
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(handleMemoryWarning),
            name: UIApplication.didReceiveMemoryWarningNotification,
            object: nil
        )
    }
    
    @objc private func handleMemoryWarning() {
        if lockedWallID == nil {
            Task {
                await performCleanup()
            }
        }
    }
    
    private func performCleanup() async {
        guard lockedWallID == nil else { return }
        
        let unusedNodes = await planeNodeCache.getUnusedNodes()
        for identifier in unusedNodes {
            do {
                try await planeNodeCache.remove(identifier: identifier)
            } catch {
                await handleError(error)
            }
        }
    }
    
    deinit {
        NotificationCenter.default.removeObserver(self)
        renderTasks.values.forEach { $0.cancel() }
        renderTasks.removeAll()
        cleanupTask?.cancel()
        intersectionCheckTask?.cancel()
    }
    
    func lockWall(with identifier: UUID) async {
        let detectedWalls = await MainActor.run { parent.viewModel.detectedWalls }
        guard let targetWall = detectedWalls.first(where: { $0.identifier == identifier }) else { return }
        
        self.lockedWallID = identifier
        
        for wall in detectedWalls where wall.identifier != identifier {
            try? await planeNodeCache.remove(identifier: wall.identifier)
            await wallGroupManager.removeWall(wall)
        }
        
        await updateDetectedWalls { walls in
            walls = [targetWall]
        }
        
        guard let arView = arViewHolder.view else { return }
        let configuration = ARWorldTrackingConfiguration()
        configuration.planeDetection = [.vertical]
        await arView.session.run(configuration, options: [])
    }
    
    func unlockWall() async {
        self.lockedWallID = nil
        
        let detectedWalls = await MainActor.run { parent.viewModel.detectedWalls }
        
        for wall in detectedWalls {
            try? await planeNodeCache.remove(identifier: wall.identifier)
            await wallGroupManager.removeWall(wall)
        }
        
        await updateDetectedWalls { walls in
            walls.removeAll()
        }
        
        guard let arView = arViewHolder.view else { return }
        let configuration = ARWorldTrackingConfiguration()
        configuration.planeDetection = [.vertical]
        await arView.session.run(
            configuration,
            options: [.resetTracking, .removeExistingAnchors]
        )
    }
}

================
File: Graffix-AR/Features/WallDetection/Views/ARView/Rendering/PlaneNodeCache.swift
================
import SceneKit

actor PlaneNodeCache {
    private let maxNodes: Int
    private let cleanupInterval: TimeInterval
    private let unusedThreshold: TimeInterval = 30
    private let emergencyThreshold: Int
    
    private var nodes: [UUID: CachedNode] = [:]
    private var lastCleanupTime: Date
    private var cleanupTask: Task<Void, Never>?
    private var isInitialized = false
    
    struct CachedNode {
        let node: SCNNode
        let lastAccessed: Date
        let createdAt: Date
    }
    
    init(maxNodes: Int = 30, cleanupInterval: TimeInterval = 15) {
        self.maxNodes = maxNodes
        self.cleanupInterval = cleanupInterval
        self.emergencyThreshold = Int(Double(maxNodes) * 0.9)
        self.lastCleanupTime = Date()
    }
    
    func initialize() throws {
        guard !isInitialized else { return }
        isInitialized = true
        startAutoCleanup()
    }
    
    func store(identifier: UUID, node: SCNNode) async throws {
        guard isInitialized else {
            throw AppError.system(.unexpectedState("キャッシュが初期化されていません"))
        }
        
        if nodes.count >= emergencyThreshold {
            try await performEmergencyCleanup()
        }
        
        nodes[identifier] = CachedNode(
            node: node,
            lastAccessed: Date(),
            createdAt: Date()
        )
    }
    
    func getNode(for identifier: UUID) async throws -> SCNNode {
        guard isInitialized else {
            throw AppError.system(.unexpectedState("キャッシュが初期化されていません"))
        }
        
        guard let cached = nodes[identifier] else {
            throw AppError.system(.resourceLimit("ノードが見つかりません: \(identifier)"))
        }
        
        nodes[identifier] = CachedNode(
            node: cached.node,
            lastAccessed: Date(),
            createdAt: cached.createdAt
        )
        
        return cached.node
    }
    
    func remove(identifier: UUID) async throws {
        guard let node = nodes[identifier]?.node else {
            throw AppError.system(.resourceLimit("削除対象のノードが見つかりません: \(identifier)"))
        }
        
        await MainActor.run {
            node.removeFromParentNode()
        }
        
        nodes.removeValue(forKey: identifier)
    }
    
    func getUnusedNodes(threshold: TimeInterval = 30) async -> [UUID] {
        let now = Date()
        return nodes.filter { now.timeIntervalSince($0.value.lastAccessed) > threshold }
            .map { $0.key }
    }
    
    private func startAutoCleanup() {
        cleanupTask = Task { [weak self] in
            while !Task.isCancelled {
                do {
                    try await self?.performCleanup()
                    guard let interval = self?.cleanupInterval else { break }
                    try await Task.sleep(nanoseconds: UInt64(interval * 1_000_000_000))
                } catch {
                    print("⚠️ Cleanup error: \(error.localizedDescription)")
                }
            }
        }
    }
    
    private func performCleanup() async throws {
        let now = Date()
        let oldNodes = nodes.filter { now.timeIntervalSince($0.value.lastAccessed) > unusedThreshold }
        
        for identifier in oldNodes.keys {
            try await remove(identifier: identifier)
        }
        
        lastCleanupTime = now
    }
    
    private func performEmergencyCleanup() async throws {
        let nodesToRemove = Int(Double(nodes.count) * 0.2)
        let sortedNodes = nodes.sorted { $0.value.lastAccessed < $1.value.lastAccessed }
        
        for i in 0..<min(nodesToRemove, sortedNodes.count) {
            try await remove(identifier: sortedNodes[i].key)
        }
    }
    
    deinit {
        cleanupTask?.cancel()
    }
}

================
File: Graffix-AR/Features/WallDetection/Views/ARView/Rendering/PlaneNodeFactory.swift
================
import SceneKit
import ARKit

class PlaneNodeFactory {
    static func createPlaneNode(for anchor: ARPlaneAnchor, color: UIColor) -> SCNNode {
        let planeGeometry = createPlaneGeometry(for: anchor)
        let material = createMaterial(with: color)
        planeGeometry.materials = [material]
        
        let planeNode = SCNNode(geometry: planeGeometry)
        planeNode.simdPosition = anchor.center
        planeNode.eulerAngles.x = -Float.pi / 2
        
        let borderNode = createBorderNode(for: planeGeometry, color: color.withAlphaComponent(0.8))
        planeNode.addChildNode(borderNode)
        
        return planeNode
    }
    
    private static func createPlaneGeometry(for anchor: ARPlaneAnchor) -> SCNPlane {
        if #available(iOS 16.0, *) {
            return SCNPlane(width: CGFloat(anchor.planeExtent.width),
                            height: CGFloat(anchor.planeExtent.height))
        } else {
            return SCNPlane(width: CGFloat(anchor.extent.x),
                            height: CGFloat(anchor.extent.z))
        }
    }
    
    private static func createMaterial(with color: UIColor) -> SCNMaterial {
        let material = SCNMaterial()
        material.diffuse.contents = color
        material.isDoubleSided = true
        material.lightingModel = .constant
        material.writesToDepthBuffer = true
        material.readsFromDepthBuffer = true
        return material
    }
    
    private static func createBorderNode(for geometry: SCNPlane, color: UIColor) -> SCNNode {
        let borderGeometry = SCNPlane(width: geometry.width + 0.01,
                                      height: geometry.height + 0.01)
        
        let material = SCNMaterial()
        material.diffuse.contents = color
        material.isDoubleSided = true
        material.lightingModel = .constant
        
        borderGeometry.materials = [material]
        
        let borderNode = SCNNode(geometry: borderGeometry)
        borderNode.position.z = 0.001
        
        return borderNode
    }
}

================
File: Graffix-AR/Features/WallDetection/Views/ARView/Rendering/PlaneNodeUpdater.swift
================
import SceneKit
import ARKit

class PlaneNodeUpdater {
    static func updatePlaneNode(_ node: SCNNode, with anchor: ARPlaneAnchor) {
        node.simdPosition = anchor.center
        
        if let geometry = node.geometry as? SCNPlane {
            let newWidth: CGFloat
            let newHeight: CGFloat
            
            if #available(iOS 16.0, *) {
                newWidth = CGFloat(anchor.planeExtent.width)
                newHeight = CGFloat(anchor.planeExtent.height)
            } else {
                newWidth = CGFloat(anchor.extent.x)
                newHeight = CGFloat(anchor.extent.z)
            }
            
            geometry.width = newWidth
            geometry.height = newHeight
            
            if let borderNode = node.childNodes.first,
               let borderGeometry = borderNode.geometry as? SCNPlane {
                borderGeometry.width = newWidth + 0.01
                borderGeometry.height = newHeight + 0.01
            }
        }
    }
}

================
File: Graffix-AR/Features/WallDetection/Views/ARView/WallManagement/WallColorManager.swift
================
import UIKit

actor WallColorManager {
    private var colorMap: [UUID: UIColor] = [:]
    private var nextColorIndex = 0
    
    private let colors: [UIColor] = [
        UIColor(red: 0.0, green: 0.8, blue: 0.0, alpha: 0.5),
        UIColor(red: 0.0, green: 0.4, blue: 1.0, alpha: 0.5),
        UIColor(red: 1.0, green: 0.5, blue: 0.0, alpha: 0.5),
        UIColor(red: 0.7, green: 0.0, blue: 1.0, alpha: 0.5),
        UIColor(red: 1.0, green: 0.0, blue: 0.5, alpha: 0.5),
        UIColor(red: 1.0, green: 0.8, blue: 0.0, alpha: 0.5),
        UIColor(red: 0.0, green: 0.7, blue: 0.7, alpha: 0.5),
        UIColor(red: 1.0, green: 0.0, blue: 0.0, alpha: 0.5),
        UIColor(red: 0.5, green: 0.8, blue: 0.0, alpha: 0.5),
        UIColor(red: 0.0, green: 0.5, blue: 0.5, alpha: 0.5)
    ]
    
    func getColor(for groupID: UUID) async -> UIColor {
        return colorMap[groupID] ?? UIColor.gray
    }
    
    func assignColor(for groupID: UUID) async {
        colorMap[groupID] = colors[nextColorIndex % colors.count]
        nextColorIndex += 1
    }
    
    func releaseColor(for groupID: UUID) async {
        colorMap.removeValue(forKey: groupID)
    }
}

================
File: Graffix-AR/Features/WallDetection/Views/ARView/WallManagement/WallGroupCache.swift
================
import Foundation
import ARKit

actor WallGroupCache {
    private let maxGroups: Int
    private let cleanupThreshold: Int
    private var lastCleanupTime: Date
    private let cleanupInterval: TimeInterval
    private var isInitialized = false
    private var cleanupTask: Task<Void, Never>?
    
    private var groups: [UUID: CachedWallGroup] = [:]
    
    struct CachedWallGroup {
        let anchors: [ARPlaneAnchor]
        let lastAccessed: Date
        let createdAt: Date
    }
    
    init(maxGroups: Int = 20, cleanupThreshold: Int = 15, cleanupInterval: TimeInterval = 30) {
        self.maxGroups = maxGroups
        self.cleanupThreshold = cleanupThreshold
        self.cleanupInterval = cleanupInterval
        self.lastCleanupTime = Date()
    }
    
    func initialize() {
        guard !isInitialized else { return }
        isInitialized = true
        startAutoCleanup()
    }
    
    private func startAutoCleanup() {
        cleanupTask = Task { [weak self] in
            while !Task.isCancelled {
                await self?.performCleanup()
                try? await Task.sleep(nanoseconds: UInt64(30 * 1_000_000_000))
            }
        }
    }
    
    func store(groupID: UUID, anchors: [ARPlaneAnchor]) async {
        await performCleanupIfNeeded()
        
        groups[groupID] = CachedWallGroup(
            anchors: anchors,
            lastAccessed: Date(),
            createdAt: Date()
        )
        
        if groups.count > maxGroups {
            await removeOldestGroup()
        }
    }
    
    func getAnchors(for groupID: UUID) async -> [ARPlaneAnchor]? {
        guard let cached = groups[groupID] else { return nil }
        
        groups[groupID] = CachedWallGroup(
            anchors: cached.anchors,
            lastAccessed: Date(),
            createdAt: cached.createdAt
        )
        
        return cached.anchors
    }
    
    func getAllGroups() async -> [(UUID, [ARPlaneAnchor])] {
        return groups.map { ($0.key, $0.value.anchors) }
    }
    
    func remove(groupID: UUID) {
        groups.removeValue(forKey: groupID)
    }
    
    private func performCleanupIfNeeded() async {
        let now = Date()
        guard now.timeIntervalSince(lastCleanupTime) > cleanupInterval else { return }
        await performCleanup()
    }
    
    private func performCleanup() async {
        let now = Date()
        let unusedThreshold: TimeInterval = 60 // 1分以上アクセスのないグループを削除
        
        let oldGroups = groups.filter { now.timeIntervalSince($0.value.lastAccessed) > unusedThreshold }
        for groupID in oldGroups.keys {
            groups.removeValue(forKey: groupID)
        }
        
        lastCleanupTime = now
    }
    
    private func removeOldestGroup() async {
        guard let oldest = groups.min(by: { $0.value.lastAccessed < $1.value.lastAccessed }) else { return }
        groups.removeValue(forKey: oldest.key)
    }
    
    deinit {
        cleanupTask?.cancel()
    }
}

================
File: Graffix-AR/Features/WallDetection/Views/ARView/WallManagement/WallGroupManager.swift
================
import ARKit

actor WallGroupManager {
    private let cache: WallGroupCache
    private let colorManager: WallColorManager
    
    init() {
        self.cache = WallGroupCache()
        self.colorManager = WallColorManager()
        Task {
            await cache.initialize()
        }
    }
    
    func addWall(_ wall: ARPlaneAnchor) async throws -> UUID {
        guard wall.alignment == .vertical else {
            throw AppError.ar(.wallGroupError("垂直な壁面のみ追加できます"))
        }
        
        let groups = await cache.getAllGroups()
        for (groupID, anchors) in groups {
            if await isWallCompatible(wall, with: anchors) {
                var updatedAnchors = anchors
                updatedAnchors.append(wall)
                await cache.store(groupID: groupID, anchors: updatedAnchors)
                return groupID
            }
        }
        
        let newGroupID = UUID()
        await cache.store(groupID: newGroupID, anchors: [wall])
        await colorManager.assignColor(for: newGroupID)
        return newGroupID
    }
    
    func removeWall(_ wall: ARPlaneAnchor) async {
        let groups = await cache.getAllGroups()
        for (groupID, anchors) in groups {
            if anchors.contains(where: { $0.identifier == wall.identifier }) {
                let updatedAnchors = anchors.filter { $0.identifier != wall.identifier }
                if updatedAnchors.isEmpty {
                    await cache.remove(groupID: groupID)
                    await colorManager.releaseColor(for: groupID)
                } else {
                    await cache.store(groupID: groupID, anchors: updatedAnchors)
                }
                return
            }
        }
    }
    
    func isWallCompatible(_ wall: ARPlaneAnchor, with groupWalls: [ARPlaneAnchor]) async -> Bool {
        guard wall.alignment == .vertical else { return false }
        
        let wallData = wall.planeNormalAndPosition
        
        for groupWall in groupWalls {
            let groupWallData = groupWall.planeNormalAndPosition
            
            let normalDifference = wallData.normal.distance(to: groupWallData.normal)
            let positionDifference = wallData.position.distance(to: groupWallData.position)
            
            if normalDifference < 0.1 && positionDifference < 0.5 {
                return true
            }
        }
        return false
    }
    
    func getColor(for groupID: UUID) async -> UIColor {
        return await colorManager.getColor(for: groupID)
    }
    
    func isInSameGroup(_ wall1: ARPlaneAnchor, as wall2: ARPlaneAnchor) async -> Bool {
        let groups = await cache.getAllGroups()
        return groups.contains { _, anchors in
            anchors.contains { $0.identifier == wall1.identifier } &&
            anchors.contains { $0.identifier == wall2.identifier }
        }
    }
    
    func reset() async {
        let groups = await cache.getAllGroups()
        for (groupID, _) in groups {
            await cache.remove(groupID: groupID)
            await colorManager.releaseColor(for: groupID)
        }
    }
}

================
File: Graffix-AR/Features/WallDetection/Views/ARView/ARContentView.swift
================
import SwiftUI
import ARKit

struct ARContentView: View {
    @StateObject private var viewModel: MeasurementViewModel
    @StateObject private var wallTargetingVM: WallTargetingViewModel
    private let arServices: ARServices
    
    init(viewModel: MeasurementViewModel,
         wallTargetingVM: WallTargetingViewModel) {
        _viewModel = StateObject(wrappedValue: viewModel)
        _wallTargetingVM = StateObject(wrappedValue: wallTargetingVM)
        self.arServices = ARServicesProvider()
    }
    
    var body: some View {
        ZStack {
            ARViewContainer(
                viewModel: viewModel,
                wallTargetingVM: wallTargetingVM,
                arServices: arServices
            )
            
            ReticuleMark(state: reticuleState)
                .position(x: UIScreen.main.bounds.width / 2,
                          y: UIScreen.main.bounds.height / 2)
            
            VStack(spacing: 0) {
                errorMessageBanner
                
                Spacer()
                
                if let distance = wallTargetingVM.currentDistance {
                    distanceText(distance)
                }
                
                Spacer()
                
                actionButton
                    .padding(.bottom, 34)
            }
        }
        .edgesIgnoringSafeArea(.all)
        .onAppear(perform: startMeasurement)
        .onDisappear(perform: stopMeasurement)
    }
    
    private var errorMessageBanner: some View {
        Group {
            if let errorMessage = viewModel.errorMessage {
                Text(errorMessage)
                    .foregroundColor(.white)
                    .font(.callout)
                    .multilineTextAlignment(.center)
                    .padding()
                    .background(Color.red.opacity(0.8))
                    .cornerRadius(8)
                    .padding()
                    .transition(.move(edge: .top).combined(with: .opacity))
                    .zIndex(1)
                    .padding(.top, 60)
            }
        }
        .animation(.easeInOut, value: viewModel.errorMessage)
    }
    
    private func distanceText(_ distance: Float) -> some View {
        Text(String(format: "%.1f cm", distance * 100))
            .font(.title2)
            .padding()
            .background(Color.black.opacity(0.7))
            .foregroundColor(.white)
            .cornerRadius(8)
    }
    
    private var actionButton: some View {
        Button(action: {
            Task {
                switch wallTargetingVM.targetingState {
                case .targeting:
                    await wallTargetingVM.lockWall()
                case .locked:
                    wallTargetingVM.unlockWall()
                default:
                    break
                }
            }
        }) {
            Text(wallTargetingVM.targetingState == .locked ? "固定を解除" : "壁面を固定")
                .padding()
                .background(buttonBackgroundColor)
                .foregroundColor(.white)
                .cornerRadius(8)
        }
        .disabled(!isButtonEnabled)
        .opacity(isButtonEnabled ? 1.0 : 0.5)
        .padding()
    }
    
    private var buttonBackgroundColor: Color {
        switch wallTargetingVM.targetingState {
        case .locked: return .blue
        case .targeting: return .blue
        case .searching: return .gray
        }
    }
    
    private var isButtonEnabled: Bool {
        wallTargetingVM.targetingState == .locked || wallTargetingVM.targetingState == .targeting
    }
    
    private var reticuleState: ReticuleMark.State {
        switch wallTargetingVM.targetingState {
        case .searching: return .normal
        case .targeting: return .targeting
        case .locked: return .normal
        }
    }
    
    private func startMeasurement() {
        viewModel.startMeasurement()
    }
    
    private func stopMeasurement() {
        viewModel.stopMeasurement()
    }
}

================
File: Graffix-AR/Features/WallDetection/Views/ARView/ARViewContainer.swift
================
import SwiftUI
import ARKit
import SceneKit

class ARViewHolder {
    weak var view: ARSCNView?
}

struct ARViewContainer: UIViewRepresentable {
    let viewModel: MeasurementViewModel
    let wallTargetingVM: WallTargetingViewModel
    let arServices: ARServices
    
    final class Coordinator: NSObject {
        var parent: ARViewContainer
        var sceneCoordinator: ARSceneCoordinator?
        
        init(_ parent: ARViewContainer) {
            self.parent = parent
        }
    }
    
    func makeUIView(context: Context) -> ARSCNView {
        let arView = ARSCNView()
        let sceneCoordinator = ARSceneCoordinator(self, wallTargetingVM: wallTargetingVM)
        context.coordinator.sceneCoordinator = sceneCoordinator
        sceneCoordinator.arViewHolder.view = arView
        
        if let provider = arServices as? ARServicesProvider {
            provider.setCoordinator(sceneCoordinator)
        }
        
        arServices.setupAR(arView)
        wallTargetingVM.setCoordinator(sceneCoordinator)
        
        arView.session.delegate = sceneCoordinator
        arView.delegate = sceneCoordinator
        
        return arView
    }
    
    func updateUIView(_ uiView: ARSCNView, context: Context) {}
    
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
}

================
File: Graffix-AR/Features/WallDetection/Views/Components/ReticuleMark.swift
================
// ReticuleMark.swift

import SwiftUI

// MARK: - Models

extension ReticuleMark {
    enum State {
        case normal
        case targeting
        case hidden
        
        var strokeColor: Color {
            switch self {
            case .normal:
                return .black
            case .targeting:
                return .green
            case .hidden:
                return .clear
            }
        }
    }
}

// MARK: - View

struct ReticuleMark: View {
    private enum Constants {
        static let size: CGFloat = 8
        static let strokeWidth: CGFloat = 2
        static let backgroundOpacity: Double = 0.5
    }
    
    let state: State
    
    var body: some View {
        Circle()
            .strokeBorder(state.strokeColor, lineWidth: Constants.strokeWidth)
            .frame(width: Constants.size, height: Constants.size)
            .background(
                Circle()
                    .fill(Color.white.opacity(Constants.backgroundOpacity))
                    .frame(width: Constants.size, height: Constants.size)
            )
            .opacity(state == .hidden ? 0 : 1)
    }
}

================
File: Graffix-AR/Features/WallDetection/Views/Components/WallDetectionOverlay.swift
================
import SwiftUI
import ARKit


struct WallDetectionOverlay: View {
    @ObservedObject var viewModel: MeasurementViewModel
    let onWallSelected: (ARPlaneAnchor) -> Void
    
    var body: some View {
        ZStack {
            if viewModel.detectedWalls.isEmpty {
                EmptyWallView()
            } else {
                WallMarkersView(walls: viewModel.detectedWalls, onWallSelected: onWallSelected)
            }
        }
    }
}

private struct EmptyWallView: View {
    var body: some View {
        Text("壁面を探しています...")
            .foregroundColor(.white)
            .padding()
            .background(Color.black.opacity(0.5))
            .cornerRadius(8)
    }
}

private struct WallMarkersView: View {
    let walls: [ARPlaneAnchor]
    let onWallSelected: (ARPlaneAnchor) -> Void
    
    var body: some View {
        ForEach(walls, id: \.identifier) { wall in
            WallIndicator(
                wall: wall,
                onTap: {
                    onWallSelected(wall)
                }
            )
            .position(
                x: CGFloat(wall.transform.columns.3.x * 500 + 200),
                y: CGFloat(wall.transform.columns.3.y * 500 + 400)
            )
        }
    }
}

================
File: Graffix-AR/Features/WallDetection/Views/Components/WallIndicator.swift
================
import SwiftUI
import ARKit

struct WallIndicator: View {
    let wall: ARPlaneAnchor
    let onTap: () -> Void
    
    private enum Constants {
        static let iconSize: CGFloat = 40
        static let backgroundOpacity: Double = 0.5
        static let cornerRadius: CGFloat = 4
        static let padding: CGFloat = 4
    }
    
    var body: some View {
        VStack(spacing: Constants.padding) {
            indicatorIcon
            indicatorLabel
        }
        .onTapGesture(perform: onTap)
    }
    
    private var indicatorIcon: some View {
        Image(systemName: "square.dashed")
            .font(.system(size: Constants.iconSize))
            .foregroundColor(.green)
    }
    
    private var indicatorLabel: some View {
        Text("タップして固定")
            .font(.caption)
            .foregroundColor(.white)
            .padding(Constants.padding)
            .background(Color.black.opacity(Constants.backgroundOpacity))
            .cornerRadius(Constants.cornerRadius)
    }
}

================
File: Graffix-AR/Features/WallDetection/Views/ContentView.swift
================
import SwiftUI
import ARKit

struct ContentView: View {
    var body: some View {
        let performanceMonitor = DevicePerformanceMonitor()
        let configService = ARConfigurationServiceImpl(performanceMonitor: performanceMonitor)
        let arServices = ARServicesProvider(configurationService: configService)
        
        let viewModel = MeasurementViewModel(
            distanceViewModel: DistanceViewModel(),
            wallDetectionViewModel: WallDetectionViewModel(
                wallDetectionService: WallDetectionService(arSession: ARSession())
            ),
            arServices: arServices
        )
        
        ARContentView(
            viewModel: viewModel,
            wallTargetingVM: WallTargetingViewModel()
        )
    }
}

================
File: Graffix-AR/Resources/Localization/ja.lproj/Localizable.strings
================
/* AR Tracking */
"ar.tracking.normal" = "トラッキングは正常です";
"ar.tracking.excessive_motion" = "動きが速すぎます";
"ar.tracking.insufficient_features" = "特徴点が不足しています";
"ar.tracking.initializing" = "初期化中...";
"ar.tracking.relocalizing" = "環境を再認識中...";
"ar.tracking.limited" = "トラッキングが制限されています";
"ar.tracking.not_available" = "トラッキングできません";

/* AR Session */
"ar.session.failed" = "ARセッションエラー";
"ar.not_available" = "AR機能を利用できません";
"ar.initialization" = "初期化中";
"ar.relocalizing" = "再認識中";
"ar.insufficient_features" = "特徴点が不足しています";
"ar.excessive_motion" = "動きが速すぎます";
"ar.cache.error" = "キャッシュエラー: %@";
"ar.wall.error" = "壁面エラー: %@";

/* AR Recovery */
"ar.recovery.slow_down" = "デバイスの動きを遅くしてください";
"ar.recovery.more_features" = "明るい場所で使用してください";
"ar.recovery.wait" = "しばらくお待ちください";
"ar.recovery.general" = "別の場所で試してください";
"ar.recovery.restart" = "アプリを再起動してください";
"ar.recovery.restart_session" = "ARセッションを再起動してください";
"ar.recovery.check_device" = "デバイスがARに対応しているか確認してください";
"ar.recovery.scan_area" = "周囲の環境を再スキャンしてください";
"ar.recovery.more_light" = "より明るい場所で試してください";
"ar.recovery.restart_app" = "アプリを再起動して再度試してください";
"ar.recovery.rescan_wall" = "壁面を再スキャンしてください";

/* Sensor */
"sensor.init.failed" = "センサーの初期化に失敗しました";
"sensor.calibration.required" = "センサーのキャリブレーションが必要です";
"sensor.system.overload" = "システムの負荷が高すぎます";
"sensor.consecutive.errors" = "連続してエラーが発生しています";
"sensor.resource.unavailable" = "センサーリソースを利用できません";
"sensor.measurement.error" = "測定エラー: %@";
"sensor.data.invalid" = "センサーデータが無効です";

/* Sensor Recovery */
"sensor.recovery.restart" = "アプリを再起動してください";
"sensor.recovery.calibrate" = "センサーのキャリブレーションを実行してください";
"sensor.recovery.close_apps" = "他のアプリを終了してください";
"sensor.recovery.reset" = "センサーをリセットしてください";
"sensor.recovery.check_usage" = "他のアプリのセンサー使用を確認してください";
"sensor.recovery.retry" = "もう一度試してください";

/* System */
"system.memory.warning" = "メモリが不足しています";
"system.task.cancelled" = "タスクがキャンセルされました";
"system.resource.limit" = "リソース制限: %@";
"system.unexpected.state" = "予期しない状態: %@";

/* System Recovery */
"system.recovery.free_memory" = "他のアプリを終了してメモリを解放してください";
"system.recovery.retry" = "もう一度試してください";
"system.recovery.free_resources" = "使用していないリソースを解放してください";
"system.recovery.restart" = "アプリを再起動してください";

================
File: Graffix-AR.xcodeproj/project.xcworkspace/contents.xcworkspacedata
================
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "self:">
   </FileRef>
</Workspace>

================
File: Graffix-AR.xcodeproj/xcshareddata/xcschemes/Mock Up.xcscheme
================
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   LastUpgradeVersion = "1620"
   version = "1.7">
   <BuildAction
      parallelizeBuildables = "YES"
      buildImplicitDependencies = "YES"
      buildArchitectures = "Automatic">
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "948981852CDD989100022640"
               BuildableName = "Graffix-AR.app"
               BlueprintName = "Graffix-AR"
               ReferencedContainer = "container:Graffix-AR.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      shouldUseLaunchSchemeArgsEnv = "YES"
      shouldAutocreateTestPlan = "YES">
   </TestAction>
   <LaunchAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      launchStyle = "0"
      useCustomWorkingDirectory = "NO"
      ignoresPersistentStateOnLaunch = "NO"
      debugDocumentVersioning = "YES"
      debugServiceExtension = "internal"
      allowLocationSimulation = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "948981852CDD989100022640"
            BuildableName = "Graffix-AR.app"
            BlueprintName = "Graffix-AR"
            ReferencedContainer = "container:Graffix-AR.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </LaunchAction>
   <ProfileAction
      buildConfiguration = "Release"
      shouldUseLaunchSchemeArgsEnv = "YES"
      savedToolIdentifier = ""
      useCustomWorkingDirectory = "NO"
      debugDocumentVersioning = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "948981852CDD989100022640"
            BuildableName = "Graffix-AR.app"
            BlueprintName = "Graffix-AR"
            ReferencedContainer = "container:Graffix-AR.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </ProfileAction>
   <AnalyzeAction
      buildConfiguration = "Debug">
   </AnalyzeAction>
   <ArchiveAction
      buildConfiguration = "Release"
      revealArchiveInOrganizer = "YES">
   </ArchiveAction>
</Scheme>

================
File: Graffix-AR.xcodeproj/xcuserdata/shinma.xcuserdatad/xcschemes/xcschememanagement.plist
================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>SchemeUserState</key>
	<dict>
		<key>Mock Up.xcscheme_^#shared#^_</key>
		<dict>
			<key>isShown</key>
			<true/>
			<key>orderHint</key>
			<integer>2</integer>
		</dict>
	</dict>
	<key>SuppressBuildableAutocreation</key>
	<dict>
		<key>948981852CDD989100022640</key>
		<dict>
			<key>primary</key>
			<true/>
		</dict>
		<key>948981952CDD989200022640</key>
		<dict>
			<key>primary</key>
			<true/>
		</dict>
		<key>9489819F2CDD989200022640</key>
		<dict>
			<key>primary</key>
			<true/>
		</dict>
	</dict>
</dict>
</plist>

================
File: Graffix-AR.xcodeproj/project.pbxproj
================
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 77;
	objects = {

/* Begin PBXContainerItemProxy section */
		948981972CDD989200022640 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = 9489817E2CDD989100022640 /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = 948981852CDD989100022640;
			remoteInfo = ARtest;
		};
		948981A12CDD989200022640 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = 9489817E2CDD989100022640 /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = 948981852CDD989100022640;
			remoteInfo = ARtest;
		};
/* End PBXContainerItemProxy section */

/* Begin PBXFileReference section */
		948981862CDD989100022640 /* Graffix-AR.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = "Graffix-AR.app"; sourceTree = BUILT_PRODUCTS_DIR; };
		948981962CDD989200022640 /* Graffix-ARTests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = "Graffix-ARTests.xctest"; sourceTree = BUILT_PRODUCTS_DIR; };
		948981A02CDD989200022640 /* Graffix-ARUITests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = "Graffix-ARUITests.xctest"; sourceTree = BUILT_PRODUCTS_DIR; };
/* End PBXFileReference section */

/* Begin PBXFileSystemSynchronizedBuildFileExceptionSet section */
		943324992D39EFEC000FF42C /* Exceptions for "Graffix-AR" folder in "Graffix-AR" target */ = {
			isa = PBXFileSystemSynchronizedBuildFileExceptionSet;
			membershipExceptions = (
				App/Info.plist,
			);
			target = 948981852CDD989100022640 /* Graffix-AR */;
		};
/* End PBXFileSystemSynchronizedBuildFileExceptionSet section */

/* Begin PBXFileSystemSynchronizedRootGroup section */
		948981882CDD989100022640 /* Graffix-AR */ = {
			isa = PBXFileSystemSynchronizedRootGroup;
			exceptions = (
				943324992D39EFEC000FF42C /* Exceptions for "Graffix-AR" folder in "Graffix-AR" target */,
			);
			path = "Graffix-AR";
			sourceTree = "<group>";
		};
/* End PBXFileSystemSynchronizedRootGroup section */

/* Begin PBXFrameworksBuildPhase section */
		948981832CDD989100022640 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		948981932CDD989200022640 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		9489819D2CDD989200022640 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		9489817D2CDD989100022640 = {
			isa = PBXGroup;
			children = (
				948981882CDD989100022640 /* Graffix-AR */,
				948981872CDD989100022640 /* Products */,
			);
			sourceTree = "<group>";
		};
		948981872CDD989100022640 /* Products */ = {
			isa = PBXGroup;
			children = (
				948981862CDD989100022640 /* Graffix-AR.app */,
				948981962CDD989200022640 /* Graffix-ARTests.xctest */,
				948981A02CDD989200022640 /* Graffix-ARUITests.xctest */,
			);
			name = Products;
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXNativeTarget section */
		948981852CDD989100022640 /* Graffix-AR */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 948981AA2CDD989200022640 /* Build configuration list for PBXNativeTarget "Graffix-AR" */;
			buildPhases = (
				948981822CDD989100022640 /* Sources */,
				948981832CDD989100022640 /* Frameworks */,
				948981842CDD989100022640 /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
			);
			fileSystemSynchronizedGroups = (
				948981882CDD989100022640 /* Graffix-AR */,
			);
			name = "Graffix-AR";
			packageProductDependencies = (
			);
			productName = ARtest;
			productReference = 948981862CDD989100022640 /* Graffix-AR.app */;
			productType = "com.apple.product-type.application";
		};
		948981952CDD989200022640 /* Graffix-ARTests */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 948981AD2CDD989200022640 /* Build configuration list for PBXNativeTarget "Graffix-ARTests" */;
			buildPhases = (
				948981922CDD989200022640 /* Sources */,
				948981932CDD989200022640 /* Frameworks */,
				948981942CDD989200022640 /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
				948981982CDD989200022640 /* PBXTargetDependency */,
			);
			name = "Graffix-ARTests";
			packageProductDependencies = (
			);
			productName = ARtestTests;
			productReference = 948981962CDD989200022640 /* Graffix-ARTests.xctest */;
			productType = "com.apple.product-type.bundle.unit-test";
		};
		9489819F2CDD989200022640 /* Graffix-ARUITests */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 948981B02CDD989200022640 /* Build configuration list for PBXNativeTarget "Graffix-ARUITests" */;
			buildPhases = (
				9489819C2CDD989200022640 /* Sources */,
				9489819D2CDD989200022640 /* Frameworks */,
				9489819E2CDD989200022640 /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
				948981A22CDD989200022640 /* PBXTargetDependency */,
			);
			name = "Graffix-ARUITests";
			packageProductDependencies = (
			);
			productName = ARtestUITests;
			productReference = 948981A02CDD989200022640 /* Graffix-ARUITests.xctest */;
			productType = "com.apple.product-type.bundle.ui-testing";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		9489817E2CDD989100022640 /* Project object */ = {
			isa = PBXProject;
			attributes = {
				BuildIndependentTargetsInParallel = 1;
				LastSwiftUpdateCheck = 1610;
				LastUpgradeCheck = 1620;
				TargetAttributes = {
					948981852CDD989100022640 = {
						CreatedOnToolsVersion = 16.1;
					};
					948981952CDD989200022640 = {
						CreatedOnToolsVersion = 16.1;
						TestTargetID = 948981852CDD989100022640;
					};
					9489819F2CDD989200022640 = {
						CreatedOnToolsVersion = 16.1;
						TestTargetID = 948981852CDD989100022640;
					};
				};
			};
			buildConfigurationList = 948981812CDD989100022640 /* Build configuration list for PBXProject "Graffix-AR" */;
			developmentRegion = en;
			hasScannedForEncodings = 0;
			knownRegions = (
				en,
				Base,
				ja,
			);
			mainGroup = 9489817D2CDD989100022640;
			minimizedProjectReferenceProxies = 1;
			preferredProjectObjectVersion = 77;
			productRefGroup = 948981872CDD989100022640 /* Products */;
			projectDirPath = "";
			projectRoot = "";
			targets = (
				948981852CDD989100022640 /* Graffix-AR */,
				948981952CDD989200022640 /* Graffix-ARTests */,
				9489819F2CDD989200022640 /* Graffix-ARUITests */,
			);
		};
/* End PBXProject section */

/* Begin PBXResourcesBuildPhase section */
		948981842CDD989100022640 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		948981942CDD989200022640 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		9489819E2CDD989200022640 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXResourcesBuildPhase section */

/* Begin PBXSourcesBuildPhase section */
		948981822CDD989100022640 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		948981922CDD989200022640 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		9489819C2CDD989200022640 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin PBXTargetDependency section */
		948981982CDD989200022640 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = 948981852CDD989100022640 /* Graffix-AR */;
			targetProxy = 948981972CDD989200022640 /* PBXContainerItemProxy */;
		};
		948981A22CDD989200022640 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = 948981852CDD989100022640 /* Graffix-AR */;
			targetProxy = 948981A12CDD989200022640 /* PBXContainerItemProxy */;
		};
/* End PBXTargetDependency section */

/* Begin XCBuildConfiguration section */
		948981A82CDD989200022640 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_LOCALIZABILITY_NONLOCALIZED = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = dwarf;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = YES;
				GCC_C_LANGUAGE_STANDARD = gnu17;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"DEBUG=1",
					"$(inherited)",
				);
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 18.1;
				LOCALIZATION_PREFERS_STRING_CATALOGS = YES;
				MTL_ENABLE_DEBUG_INFO = INCLUDE_SOURCE;
				MTL_FAST_MATH = YES;
				ONLY_ACTIVE_ARCH = YES;
				SDKROOT = iphoneos;
				SWIFT_ACTIVE_COMPILATION_CONDITIONS = "DEBUG $(inherited)";
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
			};
			name = Debug;
		};
		948981A92CDD989200022640 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_LOCALIZABILITY_NONLOCALIZED = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = YES;
				GCC_C_LANGUAGE_STANDARD = gnu17;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 18.1;
				LOCALIZATION_PREFERS_STRING_CATALOGS = YES;
				MTL_ENABLE_DEBUG_INFO = NO;
				MTL_FAST_MATH = YES;
				SDKROOT = iphoneos;
				SWIFT_COMPILATION_MODE = wholemodule;
				VALIDATE_PRODUCT = YES;
			};
			name = Release;
		};
		948981AB2CDD989200022640 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_ASSET_PATHS = "\"Graffix-AR/Assets/Preview Content\"";
				DEVELOPMENT_TEAM = 6BM2C9CM4T;
				ENABLE_PREVIEWS = YES;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_FILE = "/Users/shinma/workspace/Swift/AR_art/Graffix-AR/Graffix-AR/App/Info.plist";
				INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents = YES;
				INFOPLIST_KEY_UILaunchScreen_Generation = YES;
				INFOPLIST_KEY_UIRequiredDeviceCapabilities = arkit;
				INFOPLIST_KEY_UIStatusBarHidden = YES;
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = "UIInterfaceOrientationPortrait UIInterfaceOrientationPortraitUpsideDown UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPhone = "UIInterfaceOrientationPortrait UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.shinma.ARtest;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = 1;
			};
			name = Debug;
		};
		948981AC2CDD989200022640 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_ASSET_PATHS = "\"Graffix-AR/Assets/Preview Content\"";
				DEVELOPMENT_TEAM = 6BM2C9CM4T;
				ENABLE_PREVIEWS = YES;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_FILE = "/Users/shinma/workspace/Swift/AR_art/Graffix-AR/Graffix-AR/App/Info.plist";
				INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents = YES;
				INFOPLIST_KEY_UILaunchScreen_Generation = YES;
				INFOPLIST_KEY_UIRequiredDeviceCapabilities = arkit;
				INFOPLIST_KEY_UIStatusBarHidden = YES;
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = "UIInterfaceOrientationPortrait UIInterfaceOrientationPortraitUpsideDown UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPhone = "UIInterfaceOrientationPortrait UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.shinma.ARtest;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = 1;
			};
			name = Release;
		};
		948981AE2CDD989200022640 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = 6BM2C9CM4T;
				GENERATE_INFOPLIST_FILE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 18.1;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.shinma.ARtestTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_EMIT_LOC_STRINGS = NO;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/Graffix-AR.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/Graffix-AR";
			};
			name = Debug;
		};
		948981AF2CDD989200022640 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = 6BM2C9CM4T;
				GENERATE_INFOPLIST_FILE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 18.1;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.shinma.ARtestTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_EMIT_LOC_STRINGS = NO;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/Graffix-AR.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/Graffix-AR";
			};
			name = Release;
		};
		948981B12CDD989200022640 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = 6BM2C9CM4T;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.shinma.ARtestUITests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_EMIT_LOC_STRINGS = NO;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
				TEST_TARGET_NAME = ARtest;
			};
			name = Debug;
		};
		948981B22CDD989200022640 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = 6BM2C9CM4T;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.shinma.ARtestUITests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_EMIT_LOC_STRINGS = NO;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
				TEST_TARGET_NAME = ARtest;
			};
			name = Release;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		948981812CDD989100022640 /* Build configuration list for PBXProject "Graffix-AR" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				948981A82CDD989200022640 /* Debug */,
				948981A92CDD989200022640 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		948981AA2CDD989200022640 /* Build configuration list for PBXNativeTarget "Graffix-AR" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				948981AB2CDD989200022640 /* Debug */,
				948981AC2CDD989200022640 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		948981AD2CDD989200022640 /* Build configuration list for PBXNativeTarget "Graffix-ARTests" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				948981AE2CDD989200022640 /* Debug */,
				948981AF2CDD989200022640 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		948981B02CDD989200022640 /* Build configuration list for PBXNativeTarget "Graffix-ARUITests" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				948981B12CDD989200022640 /* Debug */,
				948981B22CDD989200022640 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
/* End XCConfigurationList section */
	};
	rootObject = 9489817E2CDD989100022640 /* Project object */;
}

================
File: .gitignore
================
# Xcodeの自動生成ファイルとユーザー設定関連
.DS_Store
*.xcuserstate
*.xcuserdata
*.xccheckout
*.xcscmblueprint
*.xcworkspace/xcuserdata/

# ビルド結果
DerivedData/
Build/
*.o
*.out
*.swp
*.bin
*.dSYM
*.tmp

# シンボルファイル
*.pbxuser
*.mode1v3
*.mode2v3
*.perspectivev3
*.pbxproj.bak
!default.mode1v3
!default.mode2v3

# ブレークポイント情報
*.xcbkptlist

# Swift Package Managerの依存関係
.swiftpm/
Package.resolved
Package.pins

# Carthageビルド関連
Carthage/Build/

# CocoaPodsの依存関係
Pods/
Podfile.lock

# Fastlaneのログ
fastlane/report.xml
fastlane/screenshots
fastlane/test_output

# Xcodeのログ
*.log
*.xcactivitylog

# アーカイブされたデータ
*.xcarchive

# Simulatorのデータ
*.simruntime
*.simdevice

# iOS Simulatorの状態保存
*.simstate

# directory_structure.txt を無視
directory_structure.txt
